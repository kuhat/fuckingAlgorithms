# 1. 位运算

## 1.1 二进制

* byte: 8 bit (-2^7, 2^7-1)
* 1 KB = 1 K Byte = 1024 Byte,  1 MB = 1024 KB ...

1. 二进制表示数字：Positive/Minus

   1 byte 最大值: 0111 1111, 最小值: 1000 0000, 最高位代表符号位。首位0代表正数，1代表负数

    2. 码

       * 5原码：0000 0101 = 2^0 + 2^2 = 5 （绝对二进制）

         5反码：1111 1010 （取反）

         5补码：1111 1011 （加一）

         -5为5的补码

       * +127原码：0111 1111

         +127反码：1000 0000

         +127补码：1000 0001

         -127为127的补码

         -128 = 1000 0000

       Java: Integer.toBinaryString(-5) = 11111111111111111111111111111011 (32位)

## 1.2 Java八大类型

byte: 1 byte (-128, 127)				boolean: 0 or 1

short: 2 byte (-2^15, 2^15-1)		char: 2 byte

int: 4 byte (-2^31, 2^31-1)			float: 4 byte

long: 8 byte (-2 ^63, 2^63-1)		double: 8 byte     

* Java中，一切皆对象，但是八大基本类型不是对象

* int 只有0没有null, Integer 有null, 是一个class. 

```java
public class BaseType {
    public static void baseType(){
        Integer b = 130;
        Integer a = 130;
        Integer x = 3;
        Integer y = 3;
        System.out.println(a == b);
        System.out.println(x == y);
    }

    public static void main(String[] args) {
        baseType();
    }
}
```

以上代码会输出`false`, `true`,  因为Java源码种把-128到127之间的数都cache了，在这之间的数可以用等号，超出了就要用`x.equals(y);`.

## 1.3 位运算

* 按位与：a & b
* 按位或：a | b
* 按位异或：a ^ b
* 按位取反：~a
* 左移：a << b
* 右移：a >> b
* 无符号右移：a >>> b 

1. 按位与

   规则：两位同时为“1”，结果才为1，否则为0

   0 & 0 = 0；

   0 & 1 = 0；

   1 & 0 = 0；

   1 & 1 = 1；

2. 按位或

   规则：参加运算的两个对象只要一个为1，其为1

   0 | 0 = 0；

   0 | 1 = 1；

   1 | 0 = 1；

   1 | 1 = 1；

   ```java
   public class Main {
    public static void temp(int[] tmp) {
           if (tmp == null || tmp.length == 0) {
    		}           
    }
    
    public static void main(String[] args){
    	int[] nunms = null;
    	temp(nums);
    }
   }
   ```

   上面代码的 `（tmp == null）|| tmp.leng == 0`顺序一定不能反，不然先执行`tmp.length==0`会报错*NullPointerException*. 

3. 按位异或

   规则：相同为零，不同为一

   0 ^ 0 = 0;

   0 ^ 1 = 1;

   1 ^ 0 = 1;

   1 ^ ! = 0;

4. 移位：左移/右移

   1 << 0: 00001 = 1:       1 >> 0: 00001 = 1;

   1 << 1: 00010 = 2;       2 >> 1: 00001 = 1;

   1 << 2: 00100 = 4;        4 >> 1 00010 = 2;

   1 << 3: 01000 = 8;        8 >> 1 00100 = 4; (和除号差不多)    

5. 无符号右移 >>>: 不管正负标志位是0还是1，将该数的二进制码整体右移，左边部分总是以0填充，右边部分舍弃。

   * -5用二进制表示**1**111 1011。第一个1是该数标志位。

     -5 >> 2: **1**111 1011 -> 11**1**1 1110。标志位向右移动了两位。

     -5 >>> 2: **1**111 1011 -> *00* **1**1 1110。前两个*0*作为补充的零，最后两个1舍弃。

   * 没有无符号左移。

## 1.4 编码标准

* 国际标准：ASCⅡ （0-127）

* 扩展的 ASCⅡ （0-255）(一般写`int[256]`)

* 字符集：Unicode (全世界的文字字符集), UTF-8, 中国GB2312

* 算法种的编码：- '0' 或者 -'a'

  ```java
  public static void encode(){
      String s = "abc";
      for (char c : s.toCharArray()){
          System.out.println(c - 'a');
      }
      System.out.println((int)'a');
  }
  ```

​	output:

	```
	 0 // 'a'-'a'
	 1 // 'b'-'a'
	 2 // 'c'-'a'
	 97 // 'a'
	```

​    计算一个字符串中每个字母出现的次数：

```java
 int[] count = new int[256];
        String d = "abc";

        for (char c: d.toCharArray()){
            int res = c - 'a';
            count[c - 'a']++;
            System.out.print(res); // 0, 1, 2
        }
System.out.println();
        for (int i : count) {
            System.out.print(i);
        } // 111000000....(253个0)
```

如果是数字，拿2应该减去0

```java
String digit = "1234";
for (char c : digit.toCharArray()){
    int res = c - '0';
    System.out.print(res);  // 1234
}
```

## 1.5 亦或XOR

* 判断唯一元素

* LeetCode136: Single Number

  Given an array of integers, every element appears twice except for one, Find the single one.

  ```java
  public static int singleNum(int[] num) {
      int res = 0;
      for (int i = 0; i < num.length; i ++) {
          res ^= num[i];  // 将数字转化为ASCⅡ编码，相同位置为0，不同位置为1
      }
      return res;
  }
  ```

* LeetCode 389: Find the Difference

  Given two Strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then *add one more letter at a random position*. Find the letter that was added in t. 

  input:

  ```java
  S = "abcd"
  t = "abcde"
  ```

  output:

  ```java
  e
  ```

  Sol:

  ```java
  // LeetCode 389
  public static int findTheDifference(String s, String t){
      char c = t.charAt(t.length() - 1);
      for (int i = 0; i < s.length(); i++) {
          c ^= s.charAt(i);
          c ^= t.charAt(i);
      }
      return c;
  }
  ```



## 1.6 n & ( n - 1)

+ 判断是2的整数次幂：`n&(n-1) == 0;`  8: 1000, 7: 0111, 8&7 = 0;

  LeetCode 231. Power of Two

  Given a integer, write a function to determine if it is a power of two.

  ```java
  public static boolean isPowerOfTwo(int n ){
      return (n>0) && ((n&(n-1)) == 0);
  }
  ```

+ 最低位为1的改为0: `n &= (n-1);` 9: 1001, 9 & (9-1) = 1001 & 1000 = 1000 

  LeetCode 191. Number of 1 Bits

  Write a function that takes an unsigned integer and returns the number of '1' bits it has.

  ```java
  public static int hammingWeight(int n) {
      int res = 0;
      while(n != 0) {
          n &= (n-1);
          res ++;
      }
      return res;
  }
  ```



## 1.7 n&1

+ 判断奇偶数 n &1 (返回1表示奇数，0表示偶数) 偶数的第0位肯定为零。

+ 末尾取1

  LeetCode191: Number of 1 bits

  ```java
  public static int hammingWeight1(int n ){
      int res = 0;
      for (int i = 0; i < 32; i++) {
          res += n & 1;
          n >>= 1; // 向右移1位
      }
      return res;
  }
  ```

## 1.8 万能Follow Up

* 数据量过大怎么办

  1. 求数组之和，数组元素有1亿个，单机装不下

     Sol1：分机解决，分10台机器，分别存储计算（分布式计算）

     Sol2: BitMap (位图) 

  2. Given an array containing n distinct numbers taken from 0, 1, 2, 3, ...., n, find the one that is missing from the array.

     ```java
     public static int missingNumber(int[] nums){
         int res = nums.length;
         for (int i = 0; i < nums.length; i++) {
             res ^= i ^ nums[i];
         }
         return res;
     }
     ```

* BitMap: 用bit表示每一位数字。`int: 4 byte = 4 * 8 = 32 bit`有多少位就用多少个bit，每个位置的数字对应bitmap上面的一个bit。如果这个位置有数字，bit值为1，如果没有数字bit的值为0。**Int** 类型有32个bit，如果有1亿个数据，就用bitmap来存储数据，就会有1亿/32个bitmap.

  Java表示：BitSet

  + Initialize 的时候是64位的，之后扩容是每次加2^6

  + `BitSet.set(i)`: 将第i位的bit设置为1

  + `BitSet.get(i)`: 得到第i位的数值，true or false

    ```java
    public static void bitSet() {
        BitSet bitSet = new BitSet();
        System.out.println(bitSet.get(0));  // false
        System.out.println(bitSet.size());  // 64
        bitSet.set(0);				       
        System.out.println(bitSet.get(0));  // true
        System.out.println(bitSet.size());  //  64
    
        bitSet.set(65);
        System.out.println(bitSet.get(65));  // true
        System.out.println(bitSet.size());   // 128
    }
    ```
    
    
    
    Implement an algorithm to determine if a string has all unique characters, what if you cannot use additional data structures?
    
    
    
    + ```java
      public static boolean isUniqueChars(String str){
          if (str.length() > 256) {
              return false;
          }
          int checker = 0;
      
          for (int i = 0; i < str.length(); i++) {
              int val = str.charAt(i);  // 将此字符转化成ASC码
              if ((checker & (1 << val)) > 0) {  // 如果任意一个字母的ASC码左移一位与上之前的值大于0就代表此字母之前出现过
                  return false;
              }
              checker |= (1<<val);  // Val 左移一位再或上checker  任何一个不同的字母的ASC码左移一位再或上之前的值该位置都是1
          }
          return true;
      }
      ```



# 2. 数学题

## 2.1  越界

+ LeetCode 7：Reverse Number

Given a signed 32-bit integer `x`, return `x` *with its digits reversed*. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-2^31, 2^31 - 1]`, then return `0`.

Java 种*Integer.Max_Value*  是 2147483647，reverse了过后就是7463847412, 肯定是越界了的。int: 4 byte (-2^31, 2^31-1), long: 8 byte (-2^63, 2^63-1), integer -> long. 

```java
// 必备代码！！！！背下来
long res = 0;
while (x != 0){
    res = res * 10 + x % 10; // 取出个位数，加上原来的数字
    x /= 10;  // 去除个位数字
    if (res > Integer.MAX_VALUE || res < Integer.MIN_VALUE){
        return 0;  //  越界的话return 0;
    }
}
return (int)res;
```

## 2.2   比较处理

```Java
System.out.println(Integer.MAX_VALUE + 2);
```

这一段代码的输出为-2147483647。

如果我们跟之前的数字对比，就会不同，可以利用这一点来解题。

```java
int res = 0;
while (x != 0){
    int cur = res;
    res = res * 10 + x % 10;
    if (res/10 != cur) return 0;
    res = res * 10 + x % 10; // 取出各位数，加上原来的数字
}
return res;
```

## 2.3  进位

从个位相加，最后进位，开辟新空间

加法：末尾开始

leetCode66: Plus one:

ou are given a **large integer** represented as an integer array `digits`, where each `digits[i]` is the `ith` digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s.

ncrement the large integer by one and return *the resulting array of digits*.

```java
public static int[] plusOne(int[] digits){
    if (digits == null || digits.length == 0) {
        return digits;
    }

    for (int i = digits.length - 1; i >= 0; i--) {
        if (digits[i] < 9) {
            digits[i] ++;
            return digits;
        }else {
            digits[i] = 0;
        }
    }
    int[] res = new int[digits.length + 1];  // 999 + 1 = 1000这种情况
    res[0] = 1;
    return res;
}
```

## 2.4  符号，字母

+ 符号：***sign***单独提取，最后处理

+ 字母：`!Character.isDihit(str.charAt(i))`.

+ LeetCode8: String to Integer (Atoi)

  ```java
  // leetCode 8: String to Integer
  class myAtoi{
      public static int myAtoi(String s){
          s = s.trim();
          if (s == null || s.length() == 0){
              return 0;
          }
          char firstChar = s.charAt(0);
          int sign = 1;
          int start = 0;
          long res = 0;
          if (firstChar == '+'){
              start++;
          } else if (firstChar == '-') {
              sign = -1;
              start ++;
          }
          for (int i = start;i < s.length(); i++){
              if (!Character.isDigit((s.charAt(i)))){  // 如果不是数字，直接return
                  return (int) res * sign;
              }
              res = res*10+s.charAt(i) - '0';
              if (sign == 1 && res > Integer.MAX_VALUE) return Integer.MAX_VALUE;  // 判断越界
              if (sign == -1 && res > Integer.MAX_VALUE) return Integer.MIN_VALUE;
          }
          return (int) res*sign;
      }    
  }
  
  ```

## 2.5 开方

Given a **positive** integer *num*, write a function which returns True if *num* is a perfect square else False.

**Follow up:** **Do not** use any built-in library function such as `sqrt`.

 

```java
// 1. 二分法 o(log(n))
public static boolean isPerfectSquare(int num){
    int low = 1;
    int high = num;
    while (low <= high){
        long mid = (high - low) / 2 + low;
        if (mid * mid == num) {
            return true;
        } else if (mid * mid < num) {
            low = (int)mid + 1;
        }else {
            high = (int)mid - 1;
        }
    }
    return false;
}
```

```java
// 2. n*n . num
public static boolean isPerfectSquare1(int num){
    if ((num)< 0) return false;
    if (num == 1) return true;
    for (int i = 1; i <= num / i; i++) {
        if (i * i == num) return true;
    }
    return false;
}
```



<img src="C:\Users\zwh52\AppData\Roaming\Typora\typora-user-images\image-20220615112513296.png" alt="image-20220615112513296" style="zoom:67%;" />

```java
// 3. 牛顿法 （切线法）

public static boolean isPerfectSquare2(int num){
    long x = num;
    while (x * x > num){
        x = (x + num / x) /2;
    }
    return x * x == num;

}
```

# 3. 数组

## 3.1 双指针

数组问题大多数都可以用双指针解决

### 3.1.1 模板一：单向双指针

```java
Object result; // 返回结果 int List String
Object temp； //临时变量，不一定有，看题
for (int i = 0; i < num.length; i ++) {
  // 处理
}

```

+ 区间问题

  1. 按start 排序

  2. 解题技巧：前一个区间 *end* & 后一个区间 *start*

     LeetCode 252: Meeting Rooms

     Given an array of meeting time intercals consisting of start and end times [[s1, e1], [s2, e2, ...]] (si < ei), determine if a person could attend all meetings.

     For example: Given [[0, 30], [5, 10], [15, 20]], return falsel.

     + 按start 排序

     + 解题技巧： 前一个区间 end & 后一个区间  start

       ```java
       public boolean conAttendMeetings(Interval[] intervals) {
       	Arrays.sort(intervals, (x, y) -> x.start - y.start);
       	for (int i = 0; i < interval.length; i ++) {
       		if (interval[i - 1].end > intervals[i].start) {
       			return false;
       		}
       	}
       	return true;
       }
       ```

       

+ 扫描线算法
  1. 在计算机图形学种，多边形填充算法 （Sweep Line）
  
  2. 中心思想：单向扫描
  
     LeetCode 153: Meeting Rooms 2
  
     Given an array of meeting time intervals consisting of start and end times [[s1, e1]. [s2, e2], ...] [si < ei], find the minimum number of conference rooms required.
  
     Example: input: [[0, 30], [5, 10], [15,20]]
  
     ​				output: 2
  
     ```java
     public int minMeetingRooms(Interval[] internals) {
     	int[] starts = new int[intervals.length];
     	int[] ends = new int[intervals.length];
     	for (int i = 0; i < intervals.length; i ++) {
     		start[i] = intervals[i].start;
     		ends[i] = intervals[i].end;
     	}
     	Arrays.sort(starts);
     	Arrays.sort(ends);
     	int end = 0;
     	int res = 0;
     	for (int i= 0; i < intervals.length; i ++) {
     		if(start[i] < ends[end]) {
     			res ++;
     		} else {
     			end ++;
     		}
     	}
     	return res;
     }
     ```
     
  
+ 子数组

  1. 解题技巧：前缀和/前缀积

  2. 处理方式：进行种处理，分段式处理 （能写成进行中就写进行中）

  3. 模板：

     ```java
     for (int i = 1; i < nums.length; i ++ ) {
         nums[i] += nums[i-1]
     }
     ```

     进行中处理：
     
     LeetCode 209: Minimum subarray Sum
     
     Given an array of positive integers `nums` and a positive integer `target`, return the minimal length of a **contiguous subarray** `[numsl, numsl+1, ..., numsr-1, numsr]` of which the sum is greater than or equal to `target`. If there is no such subarray, return `0` instead. (Sliding window)
     
     ```java
     public int minSubArrayLen(int s, int[] nums) {
     	int res = Integer.MAX_VALUE;
     	int left = 0, sum = 0;
     	for (int i = 0; i < nums.length; i ++) {
     		sum += nums[i];
             while(left <= i && sum >= s) {
                 res = Math.min(res, i - left + 1);  // left pointer move right
                 sum -= nums[left++]; // Sliding window
             }
     	}
     	return res == Integer.MAX_VALUE ? 0: res;
     }
     ```
     
     分段式处理：
     
     LeetCode 238: Product of Array Except self:
     
     Given an integer array `nums`, return *an array* `answer` *such that* `answer[i]` *is equal to the product of all the elements of* `nums` *except* `nums[i]`.
     
     The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.
     
     You must write an algorithm that runs in `O(n)` time and without using the division operation.
     
     ```java
     public int[] prodect public int[] productExceptSelf(int[] nums) {
             int[]leftmulti = new int [nums.length];
             int[]rightmulti = new int [nums.length];
             int []answer = new int[nums.length];
             int left = 1;
             int right = 1;
             
             //calculate the product for the left side
             for(int i =0; i< nums.length; i++){
                 leftmulti[i] = left;
                 left *= nums[i];
             }
             
             //calculate the product for the right side
             for(int i = nums.length -1; i >= 0; i--){
                 rightmulti[i] = right ;
                 right *= nums[i];
             }
             
             //multiplying both products together left side * right side
             for(int i = 0; i < nums.length; i++){
                 answer[i] = leftmulti[i] * rightmulti[i];
             }
             return answer;
         }
     ```
  
+ 双指针 (Two Pointer)

  + 数组问题大多都可以用双指针解决

  + 模板2： 双指针：

    ```java
    int left = 0;
    int right = nums.length - 1;
    Object res // 一般结果 int list stirng...
    while(left < right) {
    	//处理
    }
    ```

    LeetCode11: Container with most water

    ![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)

    ```java
    Input: height = [1,8,6,2,5,4,8,3,7]
    Output: 49
    Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
    ```

    Solution:

    ```java
    public int maxArea(int[] height) {
    	int res = 0;
    	int l = 0; r = height.length - 1;
    	while(l < r) {
    		res = Math.max(res, Math.min(height[l], height[r]) * (r - l));
    		if (height[i] < height[r]) {
    			l ++;
    		} else {
    			r --;
    		}
    	}
    	return res;
    }
    ```

+ 二维数组

  1. 左右翻转

  2. 上下翻转

  3. 对角线翻转（主，副）

     ```java
     // 对角线
     public static void diagonal(int[][] matrix) {
     	for(int i = 0; i < matrix.length; i ++) {
     		for (int j = 0; j < i; j ++) {
     			int temp = matrix[i][j];
     			matrix[i][j] = matrix[j][i];
     			matrix[j][i] = temp;
     		}
     	}
     }
     
     // 反对角线
     public static void counterDiagnal(int[][] matrix) {
         int len = matrix.length;
         for(int i = 0; i < len; i ++) {
     		for (int j = 0; j < len - 1- i; j ++) {
     			int temp = matrix[i][j];
     			matrix[i][j] = matrix[len - 1 -j][len - 1- i];
     			matrix[len - 1- j][len - 1- i] = temp;
     		}
     	}
     }
     
     //水平
     public static void horizontal(int[][] matrix) {
         int len = matrix.length;
         for (int i = 0; i < len; i ++) {
             for(int j = 0; j < len; j ++) {
                 int temp = matrix[i][j];
                 matrix[i][j] = matrix[len - 1- i][j];
                 matrix[len - 1 -i][j] = temp;
             }
         }
     }
     
     // 竖直
     public static void vertical(int[][] matrix) {
         int len = matrix.length;
         for (int i = 0; i < len; i ++) {
             for(int j = 0; j < len; j ++) {
                 int temp = matrix[i][j];
                 matrix[i][j] = matrix[i][len - 1 - j];
                 matrix[i][len - 1 -j] = temp;
             }
         }
     }
     ```
     
     
     
     LeetCode 48: Rotate Image
     
     You are given an `n x n` 2D `matrix` representing an image, rotate the image by **90** degrees (clockwise).
     
     You have to rotate the image [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm), which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.
     
      ![img](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)
     
     ```java
     Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
     Output: [[7,4,1],[8,5,2],[9,6,3]]
     ```
     
     Solution:
     
     ```java
     //先对角再竖直
     public static void diagonal(int[][] matrix) {
         
     }
     
     
     ```
     
     LeadCode54: Spiral matrix (原型题背)
     
     Given an `m x n` `matrix`, return *all elements of the* `matrix` *in spiral order*.
     
     ![img](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)
     
     ```java
     Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
     Output: [1,2,3,6,9,8,7,4,5]
     ```
     
     Solution:
     
     ```java
     Public List<Integer> SpiralOrder(int[][] matrix){
     	List<Integer> res = new ArrayList<>();
     	if (matrix == null || matrix.length ==0 || matrix[0] == null || matrix[0].length == 0) {
             return res;
         }
         int rowBegin = 0;
         int rowEnd = matrix.length -1;
         int colBegin = 0;
         int colEnd = matrix[0].length - 1;
         
         while (rowBegin <= rowEnd && colBegin <= colEnd) {
             for(int i = colBegin; i <= colEnd; i ++) {
                 res.add(matrix[rowBegin][i]);
             }
             rowBegin ++;
             for(int i = rowBegin; i <= rowEnd; i ++) {
                 res.add(matrix[i][colEnd]);
             }
             colEnd--;
             
             if(rowBegin <= rowEnd) {
                 for(int i = colEnd; i >= colBegin; i --) {
                    res.add(matrix[rowEnd][i]);
                 }
             }
             rowEnd --;
             
             if(colBegin <= colEnd){
                 for (int i = rowEnd; i >= rowBegin; i --) {
                     res.add(matrix[i][colBegin]);
                 }
             }
             colBegin++;
         }
         return res;
     }
     ```
  
+ 实现题

  假设你是一个专业的狗仔，参加了一个 n 人派对，其中每个人被从 0 到 n - 1 标号。在这个派对人群当中可能存在一位 “名人”。所谓 “名人” 的定义是：其他所有 n - 1 个人都认识他/她，而他/她并不认识其他任何人。

  现在你想要确认这个 “名人” 是谁，或者确定这里没有 “名人”。而你唯一能做的就是问诸如 “A 你好呀，请问你认不认识 B呀？” 的问题，以确定 A 是否认识 B。你需要在（渐近意义上）尽可能少的问题内来确定这位 “名人” 是谁（或者确定这里没有 “名人”）。

  在本题中，你可以使用辅助函数 bool knows(a, b) 获取到 A 是否认识 B。请你来实现一个函数 int findCelebrity(n)。

  派对最多只会有一个 “名人” 参加。若 “名人” 存在，请返回他/她的编号；若 “名人” 不存在，请返回 -1。
  Solution:

  ```java
  public int findCelebrity(int n) {
  	if (n < 2) return -1;
      int res = 0;
      for(int i = 1; i < n; i ++) { // 如果有的话一定会遍历到名人
          if(knows(res, i)) {
              res = i;  // 名人不认识任何人，之前的名人不是了
          }
      }
      
      // 如果名人不存在
      for(int i = 0; i < n; i ++) {
          if(re != i && ((knows(res, i) || !knows(i, res)))) {
              return -1;  // 名人不认识任何人，任何人都认识名人
          }
      }
      return res;
  }
  ```

+ 数学定理

  Moore Voting Algorithm:

  每次找出一对不同的元素，从数组中删掉，直到数组为空或者只剩下一种元素，如果存在元素e出现频率超过一半，那么数组中最后剩下的就只有e。

  LeetCode169: Majority Element

  Given an array `nums` of size `n`, return *the majority element*.

  The majority element is the element that appears more than `⌊n / 2⌋` times. You may assume that the majority element always exists in the array.

  ```java
  Input: nums = [3,2,3]
  Output: 3
  ```

  Solution：

  ```java
  // 暴力解
  public int majorityElement(int[] nums) {
  	Arrays.sort(nums);
  	return nums[nums.length / 2];
  }
  
  // Moore Voting
  public int majorityElementMoore(int[] nums) {
      int count = 0;
      int res = 0;
      for (int num : nums ) {
          if(count == 0) {
              res = nums;
          }
          if(nums != res) {
              count --;
          } 
      }
  }
  ```

  


# 4. 二分查找

+ 数组 “增删改查“的最优解

  1. 必须采用顺序存储结构
  2. 必须按关键字大小有序排列

+ 注意点：

  ```java
  int mid = (right - left) / 2 + left;
  // left + right 可能会溢出问题（大于Integer.MAX_VALUE）
  ```

+ 递归：time: O(logn), space: O(logn)

  ```java
   public static int binarySearch(int[] nums, int low, int high, int target){
          if (high < low) return -1;
          int mid = low + (high - low)/2;
          if (nums[mid] > target) {
              return binarySearch(nums, low, mid - 1, target);
          } else if (nums[mid] < target) {
              return binarySearch(nums, mid + 1, high, target);
          } else {
              return mid;
          }
      }
  ```

  logN 时间复杂度：1. 二分查找 2. PriorityQueue (Heap)
  
+ 迭代：

  1.  迭代写法 <=, `right < target < left`, `right + 1 =left`.

  ```java
  public static int binarySearch(int[] nums, int target) {
  	int left = 0;
      int right = nums.length - 1;  // [left, right]
      while(left <= right) {        // left = right
          int mid = (right - left) / 2 + left;
          if (nums[mid] > target) { // [left, mid - 1]
              right = mid - 1;
          } else if (nums[mid] < target) {  // [mid + 1, right]
              left = mid + 1;
          } else {
              return mid;
          }
      }
      return  -1;
  }
  ```

  2. 迭代写法 <， `target < left = right`, `left = right`.

     ```java
     public static int binarySearch(int[] nums, int target) {
     	int left = 0;
         int right = nums.length;  	 // [left, right) 开区间
         while(left < right) {        // left = right不执行 
             int mid = (right - left) / 2 + left;
             if (nums[mid] > target) { // [left, mid）
                 right = mid;
             } else if (nums[mid] < target) {  // [mid + 1, right）
                 left = mid + 1;
             } else {
                 return mid;
             }
         }
         return  -1;
     }
     ```

  3. 迭代写法 `left + 1 < right`

     ```java
     public static int binarySearch3(int[] nums, int target) {
     	int left = 0;
         int right = nums.length - 1;  	 // [left, right] 闭区间
         while(left + 1 < right) {        // left 和 right 挨在一起时不执行 
             int mid = (right - left) / 2 + left;
             if (nums[mid] > target) { // [left, mid]
                 right = mid;
             } else if (nums[mid] < target) {  // [mid, right]
                 left = mid;
             } else {
                 return mid;
             }
         }
         if (target == nums[left]) {  // 由于left和right挨在一起时不会执行，需要额外判断停止的条件
             return left;
         } else if (target == nums[right]) {
             return right;
         }
         return  -1;
     }
     ```

     *查看LeetCode 81 和  LeetCode 33*
  
+ 数组中的二分查找

  1. **Search**, **Find** 等字眼，涉及“查”， 必定二分查找

  2. 子数组题型：LeetCode 300 (出现次数多)

  3. 一维  -> 二维，二维查找***最优解***必定是二分法

     ```java
     // Leetcode 74 Search Matrix
     
         /**
          * Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix.
          * This matrix has the following properties:
          * <p>
          * Integers in each row are sorted from left to right.
          * The first integer of each row is greater than the last integer of the previous row.
          * <p>
          * Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
          * Output: true
          * <p>
          * Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
          * Output: false
          */
         class SearchMatrix74 {
             public boolean searchMatrix(int[][] matrix, int target) {
                 int row = matrix.length;
                 int col = matrix[0].length;
                 int start = 0;
                 int end = row * col - 1;
     
                 while (start <= end) {
                     int mid = (end - start) / 2 + start;
                     int value = matrix[mid / col][mid % col];  // 当前这个值处于二维数组中的哪里（背下来）
                     if (value == target) {
                         return true;
                     } else if (value < target) {
                         start = mid + 1;
                     } else {
                         end = mid - 1;
                     }
                 }
                 return false;
             }
         }
     ```


# 5. Linked List

1. 链表单独操作

2. 和各种数据结构结合

3. ArrayList **VS** LinkedList

### 5.1 常考题型 1 —— 基本操作

1. 有无头节点: 头节点变动的时候一定会有`dummy` 节点
2. 循环逻辑：不会去写`for`循环，一般用`while`. 
3. 结束条件

```java
// LeetCode 24:
 /**
     *
     * Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without
     * modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)
     *
     *Input: head = [1,2,3,4]
     * Output: [2,1,4,3]
     *
     *Input: head = []
     * Output: []
     *
     */

    class Solution24 {
        public ListNode swapPairs(ListNode head) {
            if (head == null || head.next == null) return head;
            ListNode dummy = new ListNode(0);  // 头节点变了，要用dummy
            dummy.next = head;    // dummy ->  2 -> 1 -> 4 -> 3
            ListNode l1 = dummy;  // dummy ->  1 -> 2 -> 3 -> 4
            ListNode l2 = head;   //   ^       ^
                                  //   l1      l2                               //  l1 l2
            while (l2 != null && l2.next != null) {                             //   _______
                ListNode nextStart = l2.next.next;                              //  |       |
                l1.next = l2.next;  // 将dummy的下一个节点设为l2的下一个 画图画出来就理解了 d  1 -> 2 -> 3
                l2.next.next = l2;  // 将l2的下一个接在dummy后面
                l2.next = nextStart;
                l1 = l2;
                l2 = l2.next;
            }
            return dummy.next;
        }
    }
```

LeetCode 238: Odd Even LinkedList:

Given the `head` of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return *the reordered list*.

The **first** node is considered **odd**, and the **second** node is **even**, and so on.

Note that the relative order inside both the even and odd groups should remain as it was in the input.

You must solve the problem in `O(1)` extra space complexity and `O(n)` time complexity.

```java
class Solution {
    public ListNode oddEvenList(ListNode head) {
         if (head == null || head.next == null) return head;
            ListNode odd = head;
            ListNode even = head.next;
            ListNode evenHead = even;
            while (even != null && even.next != null) {
                odd.next = odd.next.next;
                even.next = even.next.next;
                odd = odd.next;
                even = even.next;
            }
            odd.next = evenHead;
            return head;
    }
}
```

## 5.1 翻转

+ LeetCode 206：
	 Given the head of a singly linked list, reverse the list, and return the reversed list.


  ```java
  class Solution206 {  // 背下来
          public ListNode reverseList(ListNode head) {
              if (head == null || head.next == null) return head;
              ListNode pre = null;
              while (head != null) {
                  ListNode temp = head.next;
                  head.next = pre;
                  pre = head;
                  head = temp;
              }
              return pre;
          }
      }
  ```

+ LeetCode: 92: Reverse LinkedList II

  Given the head of a singly linked list and two integers left and right where `left <= right`, reverse the nodes of the list from position left to position right, and return the reversed list.
  
  ```
  Input: head = [1,2,3,4,5], left = 2, right = 4
  Output: [1,4,3,2,5]
  ```
  
  ```
  Input: head = [5], left = 1, right = 1
  Output: [5]
  ```
  
  Sol:
  
  ```java
  class Solution {
      public ListNode reverseBetween(ListNode head, int m, int n) {
           ListNode dummy = new ListNode(0);
              dummy.next = head;
              ListNode pre = dummy;
              ListNode cur = dummy.next;
              
              for (int i = 1; i < m; i++) {
                  cur = cur.next;
                  pre = pre.next;
              }
              for (int i = 0; i < n - m; i++) {
                  ListNode temp = cur.next;
                  cur.next = temp.next;
                  temp.next = pre.next;
                  pre.next = temp;
              }
              return dummy.next;
      }
  }
  ```

## 5.2 环

+ LeetCode 141: Linked List Cycle

  Given a Linked List, determine if it has a cycle in it.

  ```java
   // 快慢指针解决
      public boolean hasCycle(ListNode head) {
          if (head == null) return false;
          // 快慢两个指针 
          // 如果有环，快指针和慢指针一定会相遇
          ListNode slow = head, fast = head;
          while (fast != null && fast.next != null) {
              slow = slow.next;
              fast = fast.next.next;
              if (slow == fast) return true;
          }
          return false;
      }
  ```

+ LeetCode 142: Linked List Cycle II

  Given the `head` of a linked list, return *the node where the cycle begins. If there is no cycle, return* `null`.

  There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to (**0-indexed**). It is `-1` if there is no cycle. **Note that** `pos` **is not passed as a parameter**.

  **Do not modify** the linked list.

  ```
  Input: head = [3,2,0,-4], pos = 1
  Output: tail connects to node index 1
  Explanation: There is a cycle in the linked list, where tail connects to the second node.
  ```

  ```
  Input: head = [1,2], pos = 0
  Output: tail connects to node index 0
  Explanation: There is a cycle in the linked list, where tail connects to the first node.
  ```

  Sol:

  通过快慢指针可以判断一个链表是否有环。如果有环，那么**快指** 

  **针走过的路径就是图中a+b+c+b**，**慢指针走过的路径就是图中a+b**，因为在相同的时 间内，快指针走过的路径是慢指针的2倍，所以这里有`a+b+c+b=2* (a+b)`，整理得到 `a=c`，也就是说图中a的路径长度和c的路径长度是一样的。 

  ![LinkedListCycle](C:\zwh\Documents\myBlog\LinkedListCycle.png)

  在相遇的时候再使用两个指针，一个从链表起始点开始，一个从相遇点开始，每次他们 都走一步，直到再次相遇，那么这个相遇点就是环的入口。

  ```java
  public class Solution {
      public ListNode detectCycle(ListNode head) {
           if (head == null || head.next == null) return null;
              ListNode slow = head;
              ListNode fast = head;
  
              while (fast != null && fast.next != null) {
                  slow = slow.next;
                  fast = fast.next.next;
                  if (fast == slow) {
                      ListNode slow2 = head;
                      while (slow != slow2) {
                          slow = slow.next;  // 第二个指针从源头开始走直到和慢指针相遇
                          slow2 = slow2.next;
                      }
                      return slow;
                  }
              }
              return null;
      }
  }
  ```


## 5.5 删除

+ LeetCode 237: Delete Node in a Linked List

  Write a function to **delete a node** in a singly-linked list. You will **not** be given access to the `head` of the list, instead you will be given access to **the node to be deleted** directly.

  It is **guaranteed** that the node to be deleted is **not a tail node** in the list.

  ```
  Input: head = [4,5,1,9], node = 5
  Output: [4,1,9]
  Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.
  ```

  ```
  Input: head = [4,5,1,9], node = 1
  Output: [4,5,9]
  Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.
  ```

  Sol:

  ```java
  class Solution {
      public void deleteNode(ListNode node) {
            if (node == null) return;
              node.val = node.next.val;
              node.next = node.next.next;
      }
  }
  ```

+ LeetCode 83: Remove Duplicates from Sorted List

  Given the `head` of a sorted linked list, *delete all duplicates such that each element appears only once*. Return *the linked list **sorted** as well*.

  ```
  Input: head = [1,1,2]
  Output: [1,2]
  ```

  ```
  Input: head = [1,1,2,3,3]
  Output: [1,2,3]
  ```

  Sol:

  ```java
  class Solution {
      public ListNode deleteDuplicates(ListNode head) {
          if (head == null || head.next == null) return head;
              ListNode cur = head;
              while (cur.next != null) {
                  if (cur.next.val == cur.val) { //如果当前节点的值和下一个节点的值相同，就把下一个节点值给删除
                      cur.next = cur.next.next;
                  } else {  //否则cur就往后移一步
                      cur = cur.next;
                  }
              }
              return head; 
      }
  }
  ```
  

# 6. Random

## 6.1 等概率抽取法

问题：如何等概率地从n个数中随机抽取m个数？

+ 缺点1：m接近n, 出现重复的次数增多
+ 缺点2：n必须知道

已有`x`个数，随机生成`x+1`个数的概率：

1次生成该数的概率：`1-x/n`

2次生成该数的概率：`(x/n) * (1 - x/n)`

......

n 次生成该数的概率：`(x/n)^(n - 1) * (1 - x/n)`.

## 6.2 LeetCode中的等概率抽取法

```java
Random rmd = new Random();
int random = md.nextInx(bound);
```

+ LeetCode 398: Random Pick Index

  Given an integer array `nums` with possible **duplicates**, randomly output the index of a given `target` number. You can assume that the given target number must exist in the array.

  Implement the `Solution` class:

  - `Solution(int[] nums)` Initializes the object with the array `nums`.
  - `int pick(int target)` Picks a random index `i` from `nums` where `nums[i] == target`. If there are multiple valid i's, then each index should have an equal probability of returning.

  ```java
  Input
  ["Solution", "pick", "pick", "pick"]
  [[[1, 2, 3, 3, 3]], [3], [1], [3]]
  Output
  [null, 4, 0, 2]
  Explanation:
  Solution solution = new Solution([1, 2, 3, 3, 3]);
  solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.
  solution.pick(1); // It should return 0. Since in the array only nums[0] is equal to 1.
  solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.
  ```

  Solution:

  ```java
  class Solution398 {
   int[] nums;
          Random random;
  
          public Solution398(int[] nums) {
              this.nums = nums;
              this.random = new Random();
          }
  
          public int pick(int target) {
              List<Integer> list = new ArrayList<>();
              for (int i = 0; i < nums.length; i++) {
                  if (nums[i] == target) {
                      list.add(i);
                  }
              }
              return list.get(random.nextInt(list.size()));
          }
  }
  
  /**
   * Your Solution object will be instantiated and called as such:
   * Solution obj = new Solution(nums);
   * int param_1 = obj.pick(target);
   */
  ```

+ LeetCode 380: 

  Implement the `RandomizedSet` class:

  - `RandomizedSet()` Initializes the `RandomizedSet` object.
  - `bool insert(int val)` Inserts an item `val` into the set if not present. Returns `true` if the item was not present, `false` otherwise.
  - `bool remove(int val)` Removes an item `val` from the set if present. Returns `true` if the item was present, `false` otherwise.
  - `int getRandom()` Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the **same probability** of being returned.

  You must implement the functions of the class such that each function works in **average** `O(1)` time complexity.

  ```java
  Input
  ["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
  [[], [1], [2], [2], [], [1], [2], []]
  Output
  [null, true, false, true, 2, true, false, 2]
  
  Explanation
  RandomizedSet randomizedSet = new RandomizedSet();
  randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.
  randomizedSet.remove(2); // Returns false as 2 does not exist in the set.
  randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].
  randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.
  randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].
  randomizedSet.insert(2); // 2 was already in the set, so return false.
  randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.
  ```

  Solution:

  ```java
  class RandomizedSet {
  
          Random rmd;
          ArrayList<Integer> list;
          HashMap<Integer, Integer> map;
  
          public RandomizedSet() {
              this.rmd = new Random();
              this.map = new HashMap<>();  // 将arrayList的index存入 map, 形成index 和数字的键值对
              this.list = new ArrayList<>();
          }
  
          public boolean insert(int val) {
              if (map.containsKey(val)) return false;
              map.put(val, list.size());
              list.add(val);
              return true;
          }
  
          public boolean remove(int val) {
              if (!map.containsKey(val)) return false;
              int index = map.remove(val);
              int lastVal = list.remove(list.size() - 1);  //删除最后一个元素
              if (index != list.size()) {
                  list.set(index, lastVal);
                  map.put(lastVal, index);
              }
              return true;
          }
  
          public int getRandom() {
              return list.get(rmd.nextInt(list.size()));
          }
  }
  
  /**
   * Your RandomizedSet object will be instantiated and called as such:
   * RandomizedSet obj = new RandomizedSet();
   * boolean param_1 = obj.insert(val);
   * boolean param_2 = obj.remove(val);
   * int param_3 = obj.getRandom();
   */
  ```

+ 蓄水池抽样

  从`n`个元素中随机抽取m个元素，但个数无法事先确定

  

  再实际应用中，往往会遇到很大数据流的情况，因此我们无法先保存整个数据流再从中选取，而是期望有一种将数据流遍历一遍就得到所选取的元素，并且保证得到的元素是随机的算法。

  + 从n 个对象中选择一个对象，但是在此之前你是不知道n的值

    解法：总是选择第一个对象，以1/2的概率选择第二个，以1/3的概率选择第三个.......以1/m的概率选择第m个对象。
    
  + 从n个元素中随机抽取m个元素：
  
    解法：前m个元素放入蓄水池，当到第k个（K > m ）时，按照 m/k的概率选中，以均等的概率去替换蓄水池中的先前被选中的任一元素。
  
    优点：不需要用数据结构去存储
  
    用法：数据流（stream）
  
    例子：给一个数据流（stream），等概率取m个数
  
    ```java
    public int[] reservairSampling(int[] stream, int k) {
    	Random rmd = new Random();
    	int[] res = new int[k];
    	
    	for(int i = 0; i < k; i ++) {
    		res[i] = stream[i];
    	}
    	
    	for(int i = k; i < stream.length; i++) {
    		int random = rmd.nextInt(i + 1);
    		if (random < k) {  // 以 k/i 的概率交换
            res[random] = stream[i];
    		}
    	}
    	return res;
    }
    ```

# 7. Stack

## 7.1 题型1：平衡符号

+ Parentheses "{}[]()".

+ 单独题型，非常典型

  ```java
  // LeetCode 20: Valid Parentheses
      /**
       * Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
       *
       * An input string is valid if:
       *
       * 1.Open brackets must be closed by the same type of brackets.
       * 2.Open brackets must be closed in the correct order.
       *
       * Input: s = "()"
       * Output: true
       *
       * Input: s = "()[]{}"
       * Output: true
       *
       * Input: s = "(]"
       * Output: false
       */
  
      class Solution20 {
          public boolean isValid(String s) {
              if (s == null || s.length() == 0) return true;
              Stack<Character> stack = new Stack<>();
              for(Character ch: s.toCharArray()) {
                  if (ch == '(') stack.push(')');
                  else if (ch == '[') stack.push(']');
                  else if (ch == '{') stack.push('}');
                  else {
                      if (stack.isEmpty() || stack.pop() != ch) return false;
                  }
              }
              return stack.isEmpty();
          }
      }
  ```

## 7.2 压栈匹配

1. 前后顺序相关联

2. 有特殊字符“[]....” 或字母代表特殊意义

3. 小模板：

   ```java
   while / For(){
   	if()
   	else if ()
   	else if ()
   	else{}
   }
   ```

   

   LeetCode 394： Decode String

   Given an encoded string, return its decoded string.

   The encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer.

   You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, `k`. For example, there will not be input like `3a` or `2[4]`.

   The test cases are generated so that the length of the output will never exceed `105`.

   ```
   Input: s = "3[a]2[bc]"
   Output: "aaabcbc"
   
   Input: s = "3[a2[c]]"
   Output: "accaccacc"
   ```

   Solution:

   ```java
   class Solution394{
           public String decodeString(String s) {
               if (s == null || s.length() == 0) {
                   return s;
               }
               Stack<Integer> numStack = new Stack<>();
               Stack<String> resStack = new Stack<>();
               String res = "";
               int idx = 0;
               while (idx < s.length()){
                   if (Character.isDigit(s.charAt(idx))){
                       int num = 0;
                       while (Character.isDigit(s.charAt(idx))) {
                           num = num * 10 + s.charAt(idx) - '0';
                           idx++;
                       }
                       numStack.push(num);
                   } else if (s.charAt(idx) == '[') {
                       resStack.push(res);
                       res = "";
                       idx++;
                   } else if (s.charAt(idx) == ']') {
                       StringBuilder temp = new StringBuilder(resStack.pop());
                       int time = numStack.pop();
                       for (int i = 0; i < time; i++) {
                           temp.append(res);
                       }
                       res = temp.toString();
                       idx++;
                   } else {
                       res += s.charAt(idx++);
                   }
   
               }
               return res;
           }
       }
   ```

## 7.3 表达式计算

1. 正常计算：`a + b * c`.

2. 逆波兰式表达法（后缀表达式）：`abc * +`.

   LeetCode  224: Basic Calculator

   Given a string `s` representing a valid expression, implement a basic calculator to evaluate it, and return *the result of the evaluation*.

   **Note:** You are **not** allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.

   ```
   Input: s = "1 + 1"
   Output: 2
   
   Input: s = " 2-1 + 2 "
   Output: 3
   ```

   Solution:

   ```java
   class Solution {
       public int calculate(String s) {
             Stack<Integer> stack = new Stack<>();
               int sign = 1;
               int res = 0;
               for (int i = 0; i < s.length(); i++) {
                   if (Character.isDigit(s.charAt(i))) {
                       int num = s.charAt(i) - '0';
                       while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1))) {
                           num = num * 10 + s.charAt(i + 1) - '0';
                           i ++;
                       }
                       res += num * sign;
                   } else if (s.charAt(i) == '+') {
                       sign = 1;
                   } else if (s.charAt(i) == '-') {
                       sign = -1;
                   } else if (s.charAt(i) == '(') {  // 遇到（，push所有算过的值放入stack，符号位也放进去
                       stack.push(res);
                       stack.push(sign);
                       res = 0;
                       sign = 1;
                   } else if (s.charAt(i) ==')') {
                       res = res * stack.pop() + stack.pop();
                   }
               }
               return res;
       }
   }
   ```

   LeetCode 150: （后缀表达式）Evaluate Reverse Polish Notation

   valuate the value of an arithmetic expression in [Reverse Polish Notation](http://en.wikipedia.org/wiki/Reverse_Polish_notation).

   Valid operators are `+`, `-`, `*`, and `/`. Each operand may be an integer or another expression.

   **Note** that division between two integers should truncate toward zero.

   It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.

   ```
   Input: tokens = ["2","1","+","3","*"]
   Output: 9
   Explanation: ((2 + 1) * 3) = 9
   
   Input: tokens = ["4","13","5","/","+"]
   Output: 6
   Explanation: (4 + (13 / 5)) = 6
   ```

   Solution:

   ```java
   class Solution {
       public int evalRPN(String[] tokens) {
           Stack<Integer> stack = new Stack<>();
               for (String s : tokens) {
                   if (s.equals("+")) {
                       stack.push(stack.pop() + stack.pop());
                   } else if (s.equals("-")) {
                       int b = stack.pop();
                       int a = stack.pop();
                       stack.push(a - b);
                   } else if (s.equals("*")) {
                       stack.push(stack.pop() * stack.pop());
                   } else if (s.equals("/")) {
                       int b = stack.pop();
                       int a = stack.pop();
                       stack.push(a / b);
                   } else {  // 当前的是数字
                       stack.push(Integer.parseInt(s));
                   }
               }
               return stack.pop();
       }
   }
   ```


## 7.4 迭代极值

+ 最近比较后，求最优解
+ 与动态规划不同点：单独拿出来也可以

    LeetCode 42: Trapping rain water

    Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.

    ![TrappingRainWater](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)

    ```
    Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
    Output: 6
    Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
    ```

    LeetCode 84: Largest Rectangle in Histogram

    Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return *the area of the largest rectangle in the histogram*.
    
    ![84](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

	```
	Input: heights = [2,1,5,6,2,3]
	Output: 10
	Explanation: The above is a histogram where width of each bar is 1.
	The largest rectangle is shown in the red area, which has an area = 10 units.
	```
	Solution:
	
	```java
	class Solution {
	    public int largestRectangleArea(int[] heights) {
	            if (heights == null || heights.length == 0) return 0;
	                Stack<Integer> stack = new Stack<>();
	                int res = 0;
	                for (int i = 0; i <= heights.length; i ++) {
	                    int hi = i == heights.length ? 0 : heights[i];
	                    while (!stack.isEmpty() && hi < heights[stack.peek()]) {
	                        int height = heights[stack.pop()];
	                        int start = stack.isEmpty() ? -1 : stack.peek();
	                        int area = height * (i - start - 1);
	                        res = Math.max(res, area);
	                    }
	                    stack.push(i);
	                }
	                return res;
	    }
	}
	```
	
	小模板：
	
	```java
	Stack<OBJ> stack = new Stack<>();
	for / while () {
		for / while (isEmpty() && 条件) {
			内部操作（取Math.min/max, push/pop）
		}
		内部操作 push/pop
	}
	```
	
	

​    

# 8. String

## 8.1 String 基本函数

1. Length()
2. equals()
3. subString()
4. indexOf()
5. lastIndexOf()
6. startsWith()
7. toCharArray()
8. charAt()
9. split()
10. trim()

字符串四重奏：

1. SubString
2. Palindrome
3. Parentheses
4. Subsequence

## 8.2 函数的时间复杂度

1. subString(): 时间复杂度：O(n)

2. indexOf() / lasdtIndexOf(): 时间复杂度：O(n * m) where n is length of the text and m is a length of them.

3. startWith(): o(n)

   + LeetCode28: Implement strStr()

     Given two strings `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`.

     **Clarification:**

     What should we return when `needle` is an empty string? This is a great question to ask during an interview.

     For the purpose of this problem, we will return 0 when `needle` is an empty string. This is consistent to C's [strstr()](http://www.cplusplus.com/reference/cstring/strstr/) and Java's [indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)).

     ```
     Input: haystack = "hello", needle = "ll"
     Output: 2
     ```

     ```
     Input: haystack = "aaaaa", needle = "bba"
     Output: -1
     ```

     Solution:

     ```java
      class Solution28 {
             public int strStr(String haystack, String needle) {
                 if (needle == null || needle.length() == 0) return 0;
                 for (int i = 0; i < haystack.length(); i++) {
                     if (i + needle.length() > haystack.length()) break;
                     for (int j = 0; j < needle.length(); j++) {
                         if (haystack.charAt(i + j) != needle.charAt(j)) break;
                         if (j == needle.length() - 1) return i;
                     }
                 }
                 return -1;
             }
     }
     ```

   + LeetCode 14: Longest Common prefix

     Write a function to find the longest common prefix string amongst an array of strings.

     If there is no common prefix, return an empty string `""`.

     ```
     Input: strs = ["flower","flow","flight"]
     Output: "fl"
     ```

     Solution:

     ```java
     class Solution14{
             public String longestCommonPrefix(String[] strs) {
                 if (strs == null || strs.length == 0) return "";
                 for (int i = 0; i < strs[0].length(); i ++) {  // 将第一个单词的字母拿出来一个接着一个遍历
                     char c = strs[0].charAt(i);
                     for (int j = 1; j < strs.length; j++) {  // 将接着的字符串的相应位置的字母拿去和第一个字母的对应位置比较
                         if (i == strs[j].length() || strs[j].charAt(i) != c ) {
                             return strs[0].substring(0, i);
                         }
                     }
                 }
                 return strs[0];  // 如果第一个单词遍历完了，直接输出第一个单词
             }
         }
     ```

## 8.3 正则表达式

用来检索和替换字符串中的内容

+ +：匹配前面的子表达式一次或多次（大于等于1次）。例如，“zo+”能匹配“zo” 以及“zoo”, 但不能匹配"z".

+ ?：匹配前面的子表达式0次或者一次。例如"do(es)?"可以匹配"do" 或者"does".

+ 常用正则表达式：

  + `String str = s.split(" ");`  分隔单个空格

  + `String str = s.split("\\s+");`  分隔多个空格

  + `String str = s.split("\\.");`   分隔`.`正则表达式中`.`代表任意字符，这时需要\\\来

  + `String str = s.split(",");`   分隔`,`

  + `String str = s.split("/+");` 分隔 `/`

    + LeetCode 165: Compare Version numbers

      Given two version numbers, `version1` and `version2`, compare them.

      

      Version numbers consist of **one or more revisions** joined by a dot `'.'`. Each revision consists of **digits** and may contain leading **zeros**. Every revision contains **at least one character**. Revisions are **0-indexed from left to right**, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example `2.5.33` and `0.1` are valid version numbers.

      To compare version numbers, compare their revisions in **left-to-right order**. Revisions are compared using their **integer value ignoring any leading zeros**. This means that revisions `1` and `001` are considered **equal**. If a version number does not specify a revision at an index, then **treat the revision as `0`**. For example, version `1.0` is less than version `1.1` because their revision 0s are the same, but their revision 1s are `0` and `1` respectively, and `0 < 1`.

      *Return the following:*

      - If `version1 < version2`, return `-1`.
      - If `version1 > version2`, return `1`.
      - Otherwise, return `0`.

      ```
      Input: version1 = "1.01", version2 = "1.001"
      Output: 0
      Explanation: Ignoring leading zeroes, both "01" and "001" represent the same integer "1".
      ```

      ```
      Input: version1 = "1.0", version2 = "1.0.0"
      Output: 0
      Explanation: version1 does not specify revision 2, which means it is treated as "0".
      ```

      Solution:

      ```java
      class Solution {
          public int compareVersion(String version1, String version2) {
                String[] v1 = version1.split("\\.");
                  String[] v2 = version2.split("\\.");
                  for (int i = 0; i < Math.max(v2.length, v1.length); i ++) {
                      int num1 = i < v1.length ? Integer.parseInt(v1[i]) : 0;
                      int num2 = i < v2.length ? Integer.parseInt(v2[i]) : 0;
                      if (num1 < num2) return -1;
                      else if (num1 > num2) return 1;
                  }
                  return 0;
          }
      }
      ```

      

## 8.4 转义字符 & 通配符

+ 转义字符：所有的ASCII 码都可以用`\`加数字（一般是8进制数字）来表示。而C中定义了一些字母前加`“\”`来表示常见的那些不能显示的ASCII的字符，如 `\0, \t, \n ` 等，就是转义字符，以为后面的字符，都不是它本来的ASCII字符意思了。字符串中一个`\`·会自动识别为转义字符，如果要表示`\`本省，需要写成`\\`
+ 通配符 (wildcard): 代替一个或者多个真正字符 （星号`*` 和 问号`?`）

    ## 8.5 String Vs. StringBuilder Vs. StringBuffer

+ leetCode 168: Excel Sheet Column Title

  Given an integer `columnNumber`, return *its corresponding column title as it appears in an Excel sheet*.

  For example:

  ```
  A -> 1
  B -> 2
  C -> 3
  ...
  Z -> 26
  AA -> 27
  AB -> 28 
  ...
  Input: columnNumber = 1
  Output: "A"
  Input: columnNumber = 28
  Output: "AB"
  ```

  Solution:

  ```java
   class Solution168{
          public String convertToTitle(int columnNumber) {
              StringBuilder sb = new StringBuilder();
              while (columnNumber > 0) {
                  columnNumber--;
                  sb.append((char)('A' + columnNumber % 26));
                  columnNumber /= 26;
              }
              return sb.reverse().toString();
          }
      }
  ```

+ String: 字符串常量，对象一经创建后该对象不可更改
+ 对String对象的任何改变都不影响到原对象，相关的任何change操作都会产生新的对象
+ StringBuilder：对象是变量，可以更改
+ StringBuilder是线程不安全的，而StringBuffer是线程安全的
+ StringBuffer很多方法可以带有synchronized关键字

## 8.6 常考题型1：Anagram

相同字母异序词

做法：count sort

小模板：

```java
int[] count = new int[26];
for(int i = 0; i < s.length(); i ++) {
	count[s.charAt(i) - 'a'] ++;
}3
```

LeetCode 242: Valid Anagram

Given two strings `s` and `t`, return `true` *if* `t` *is an anagram of* `s`*, and* `false` *otherwise*.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

Input: s = "anagram", t = "nagaram"
Output: true

```java
	 public boolean isAnagram(String s, String t) {
       if(s.length()!=t.length()) return false; // anagrams always have equal length
    // make an array to store frequency of characters (total 26 characters in the alphabet)
    int[] fmap = new int[26];     
    
    // loop through the strings because now they have equal length and store the frequency of characters of string s as positive 
	// and frequency of string t characters as negative and if they are anagrams 
	// then frequencies should cancel out each other and should be zero at every index.
    for(int i = 0; i<s.length(); i++){
        char c1 = s.charAt(i);
        char t1 = t.charAt(i);
        fmap[c1 - 'a']++;
        fmap[t1 - 'a']--;
    }
    // if there is any value that is not zero then return false immediately
    for(int val: fmap)
        if(val!=0) return false;
    
    // return true if it safely came out of the loop
    return true;       
}
```

## 8.7  常考题型SubString

+ Sliding window

  模板：

  ```java
  for(int i = 0; i < s.length(); i++) {
  	while(){
  		j++;
  	}
  }
  ```

  

+ 双指针，一前一后

  LeetCode 76: minimum window subString

  Given two strings `s` and `t` of lengths `m` and `n` respectively, return *the **minimum window substring** of* `s` *such that every character in* `t` *(**including duplicates**) is included in the window. If there is no such substring**, return the empty string* `""`*.*

  The testcases will be generated such that the answer is **unique**.

  A **substring** is a contiguous sequence of characters within the string.

  ```
  Input: s = "ADOBECODEBANC", t = "ABC"
  Output: "BANC"
  Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
  ```

  Solution:

  ```java
   // 用数组来记录每个字母出现的次数
      public String minWindow1(String s, String t) {
          int[] map = new int[128];
          for (char c : t.toCharArray()) {
              map[c]++;  // 记录字符串t中每个字符的数量
          }
          int count = t.length();
          int left = 0;  // 窗口左边界
          int right = 0;  // 窗口右边界
          int minWindowLen = Integer.MAX_VALUE;  // 覆盖t的最小长度
          int strStart = 0;  // 覆盖字符串t的开始位置
          while (right < s.length()) {
              if (map[s.charAt(right++)]-- > 0) count--;  // 如果找到一个在t中的字符，count减一
              while (count == 0) {  // 如果全部覆盖
                  if (right - left < minWindowLen) {  // 如果有更小的窗口就更新窗口
                      minWindowLen = right - left;
                      strStart = left;
                  }
                  if (map[s.charAt(left++)]++ == 0) {  // 移除最左的元素，左指针向右走
                      count++;
                  }
              }
          }
          if (minWindowLen != Integer.MAX_VALUE) {
              return s.substring(strStart, strStart + minWindowLen);
          }
          return "";
      }
      /*
      总结：滑动窗口类型的题也是最常见的，一般会有两个指针，分别指向窗口的左边界和右边界，
      如果窗口不满足条件我们就移动右边界来扩大窗口，如果满足条件我们可以移动左边界来
      缩小窗口，确定这个更小的窗口是否还满足条件……
       */
  ```

## 8.8 常考题型3 - Parentheses

+ 求单一结果：Stack

+ 求多个结果：Backtracking + Recusion

  LeetCode 32: Longest Valid Parentheses

  Given a string containing just the characters `'('` and `')'`, find the length of the longest valid (well-formed) parentheses substring.

  ```
  Input: s = "(()"
  Output: 2
  Explanation: The longest valid parentheses substring is "()".
  ```

  ```
  Input: s = ")()())"
  Output: 4
  Explanation: The longest valid parentheses substring is "()()".
  ```
  
  Solution:
  
  ```java
   class Solution32 {
          public int longestValidParentheses(String s) {
              Stack<Integer> stack = new Stack<>();
              int res = 0, j = -1;
              for (int i = 0; i < s.length(); i++) {
                  if (s.charAt(i) == '(') stack.push(i);
                  else{  
                      if (stack.isEmpty()) j = i;  // 一开始就遇到（
                      else {
                          stack.pop();
                          if (stack.isEmpty()) res = Math.max(res, i - j);
                          else res = Math.max(res, i - stack.peek());
                      }
                  }
              }
              return res;
          }
      }
  ```

## 8.9 常考题型：Palindrome

+ 求单一结果String：正常for循环

+ 求单一结果个数：动态规划

+ 求多个结果：Backtracking + Recursion

+ 模板：

  ```java
  private boolean isPalindrome(String s) {
  	int left = 0;
  	int right = s.length() - 1;
  	whiile(left < right) {
  		if(s.charAt(left) != s.charAt(right)) {
  			return false;
  		}
  	left ++;
  	right --;
  	}
  	return true;
  }
  ```

## 8.10 常考题型5：SubSequence

+ 以单一数位结果：动态规划

+ 最难的题型之一

+ # [392\. Is Subsequence](https://leetcode.com/problems/is-subsequence/submissions/)

  ## Description

  Difficulty: **Easy**  

  Related Topics: [Two Pointers](https://leetcode.com/tag/two-pointers/), [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


  Given two strings `s` and `t`, return `true` _if_ `s` _is a **subsequence** of_ `t`_, or_ `false` _otherwise_.

  A **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `"ace"` is a subsequence of `"<u>a</u>b<u>c</u>d<u>e</u>"` while `"aec"` is not).

  **Example 1:**

  ```
  Input: s = "abc", t = "ahbgdc"
  Output: true
  ```

  **Example 2:**

  ```
  Input: s = "axc", t = "ahbgdc"
  Output: false
  ```

  **Constraints:**

  *   `0 <= s.length <= 100`
  *   0 <= t.length <= 10<sup>4</sup>
  *   `s` and `t` consist only of lowercase English letters.

  **Follow up:** Suppose there are lots of incoming `s`, say s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub> where k >= 10<sup>9</sup>, and you want to check one by one to see if `t` has its subsequence. In this scenario, how would you change your code?

  ## Solution

  Language: **Java**

  ```java
  class Solution {
      public boolean isSubsequence(String s, String t) {
                      if (s == null || s.length() == 0) return true;
              int i = 0, j = 0;
              while (i < s.length() && j < t.length()) {
                  if (s.charAt(i) == t.charAt(j)) i++;
                  j++;
              }
              return i == s.length();
      }
  }
  ```

## 8.11 常考题型6：实现题

+ 从最简单到最难
+ 最常考：边界条件

# 9. 图形题

1. 点，线，面
2. 除了特殊算法，不涉及任何数据结构（HashMap除外）
3. 属于最难的题之一
4. 计算机图形学

## 9.1 题型

![image-20220713140200200](C:\zwh\Documents\myBlog\图形题型)

## 10.2 点

### 10.2.1 点在线段上

1. 点 O 是否在所在的直线（A, B）上，带入点到直线方程，算x轴的范围

   不要轻易算斜率！

2. 两点式：(y -y1)/(y2 - y1) = (x -x1)/(x2 - x1) (x1 ≠ x2, y1 ≠ y2)

### 10.2.2 向量

1. A X B = A.x * B.y - A.y * B.x

## 10.3 方向

![image-20220713145616793](C:\zwh\Documents\myBlog\图形方向)

## 10.4 点在直线上

# [149\. Max Points on a Line](https://leetcode.com/problems/max-points-on-a-line/submissions/)

## Description

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Math](https://leetcode.com/tag/math/), [Geometry](https://leetcode.com/tag/geometry/)


Given an array of `points` where points[i] = [x<sub>i</sub>, y<sub>i</sub>] represents a point on the **X-Y** plane, return _the maximum number of points that lie on the same straight line_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg)

```
Input: points = [[1,1],[2,2],[3,3]]
Output: 3
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg)

```
Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
Output: 4
```

**Constraints:**

*   `1 <= points.length <= 300`
*   `points[i].length == 2
*   -10<sup>4</sup> <= x<sub>i</sub>, y<sub>i</sub> <= 10<sup>4</sup>
*   All the points` are **unique**.


## Solution

Language: **Java**

```java
class Solution {
    
   
    public int maxPoints(int[][] points) {
            if (points == null || points.length == 0) return 0;
            if (points.length < 2) return points.length;
            int res = 0;

            for (int i = 0; i < points.length; i ++) {
                HashMap<String, Integer> map = new HashMap<>();  // 用hashmap来记录点和对应的斜率
                int samePoint = 0;
                int sameXAxis = 1;
                for (int j = 0; j < points.length; j++) {
                    if (i != j) {
                        if (points[i][0] == points[j][0] && points[i][1] == points[j][1]) {
                            samePoint++;
                        }
                        if (points[i][0] == points[j][0]) {
                            sameXAxis++;  // x = x的时候不能计算斜率
                            continue;
                        }
                        int numerator = points[i][1] - points[j][1];
                        int denominator = points[i][0] - points[j][0];
                        int gcd = gcd(numerator, denominator);  // 通过最大公约数来计算斜率
                        String hashStr = (numerator / gcd) + "/" + (denominator / gcd);
                        map.put(hashStr, map.getOrDefault(hashStr, 1) + 1);
                        res = Math.max(res, map.get(hashStr) + samePoint);
                    }
                }
                res = Math.max(res, sameXAxis);  // 垂直于x轴的点之前没有算
            }
            return res;
        }
    
        private int gcd(int a, int b) {  // 和GCD捆绑
            if (a == 0) return b;
            return gcd(b % a, a);
        }
}
```

边界条件：平行/重合

## 10.5 点与面

圆的表达式：`(x - a)^2 + (y -b)^2 = r ^2`.

点与圆的关系：

1. P在圆外，PO > r
2. P在圆上，PO = r
3. P在圆内，PO < r



# 11. 回溯法

## 11.1 二叉树的遍历

+ 三种遍历方式

  1. 前序遍历（根节点开始），顺序是**根节点** -> 左子树 -> 右子树

     ```java
     public void preOrder(TreeNode node) {
     	if ("终止条件") // 必须要有
     		return;
     	逻辑处理  // 不是必须的
     	递归调用  // 必须要有
     }
     ```

     **终止条件**是node等于空，**逻辑处理**这块直接打印当前节点的值即可，**递归调用**是先打印左子树在打印右子树:

     ```java
     public void preOrder(TreeNode node) {
     	if (node == null) return;
     	System.out.println(node.val + "");
     	preOrder(node.left);
     	preOrder(node.right);
     }
     ```

  2. 中序遍历 （根节点再中间），左子树 -> **根节点** -> 右子树

     ```java
     public void inOrder(TreeNode node) {
     	if (node == null) return;
     	inOrder(node.left);
     	System.out.println(node.val);
     	inOrder(node.right);
     }
     ```

  3. 后序遍历（根节点再最后），左子树 -> 右子树 -> **根节点**

     ```java
     public void postOrder(TreeNode tree) {
     	if (tree == null) return;
     	postOrder(tree.left);
     	postOrder(tree.right);
     	Syste.out.println(tree.val);
     }
     ```

     

+ 模板

  ```java
  private void backTrack("原始函数") {
  	// 终止条件
      if ("终止条件") {
          // 一些逻辑，（可有可无，视情况而定）
          return;
      }
      for (int i = "for 循环开始的参数"; i < "for循环借宿的参数"; i++) {
          // 一些逻辑操作（可有可无）
          
          // 做出选择
          
          // 递归
          backtrack("新的参数");
          // 一些逻辑操作（可有可无，视情况而定）
          
          // 撤销选择
      }
  }
  ```

  + 为什么要最后一步撤销选择：

    递归分为递和归两部分，递就是往下传递，归就是往回走。递归你从什么地方调用最终还会回到什么地方去，我们来画个简单的图看一下

    ![递归](https://mmbiz.qpic.cn/mmbiz_png/PGmTibd8KQBEPUibuD2icIj0YTAfagvF110FIEMic6s7zfagYiczv1Bzia6CNicg32Iv3TkxgZGd3hvbChSQ91XFxcTXw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
	
	  
	
	  这是一棵非常简单的3叉树，假如要对他进行DFS遍历，当沿着1→2这条路径走下去的时候，list中应该是[1，2]。因为是递归调用最终还会回到节点1，如果不把2给移除掉，当沿着1→4这个分支走下去的时候就变成[1，2，4]，但实际上1→4这个分支的结果应该是[1，4]，这是因为我们把前一个分支的值给带过来了。当1，2这两个节点遍历完之后最终还是返回节点1，在回到节点1的时候就应该把结点2的值给移除掉，让list变为[1]，然后再沿着1→4这个分支走下去，结果就是[1，4]。