# 1. 位运算

## 1.1 二进制

* byte: 8 bit (-2^7, 2^7-1)
* 1 KB = 1 K Byte = 1024 Byte,  1 MB = 1024 KB ...

1. 二进制表示数字：Positive/Minus

   1 byte 最大值: 0111 1111, 最小值: 1000 0000, 最高位代表符号位。首位0代表正数，1代表负数

    2. 码

       * 5原码：0000 0101 = 2^0 + 2^2 = 5 （绝对二进制）

         5反码：1111 1010 （取反）

         5补码：1111 1011 （加一）

         -5为5的补码

       * +127原码：0111 1111

         +127反码：1000 0000

         +127补码：1000 0001

         -127为127的补码

         -128 = 1000 0000

       Java: Integer.toBinaryString(-5) = 11111111111111111111111111111011 (32位)

## 1.2 Java八大类型

byte: 1 byte (-128, 127)				boolean: 0 or 1

short: 2 byte (-2^15, 2^15-1)		char: 2 byte

int: 4 byte (-2^31, 2^31-1)			float: 4 byte

long: 8 byte (-2 ^63, 2^63-1)		double: 8 byte     

* Java中，一切皆对象，但是八大基本类型不是对象

* int 只有0没有null, Integer 有null, 是一个class. 

```java
public class BaseType {
    public static void baseType(){
        Integer b = 130;
        Integer a = 130;
        Integer x = 3;
        Integer y = 3;
        System.out.println(a == b);
        System.out.println(x == y);
    }

    public static void main(String[] args) {
        baseType();
    }
}
```

以上代码会输出`false`, `true`,  因为Java源码种把-128到127之间的数都cache了，在这之间的数可以用等号，超出了就要用`x.equals(y);`.

## 1.3 位运算

* 按位与：a & b
* 按位或：a | b
* 按位异或：a ^ b
* 按位取反：~a
* 左移：a << b
* 右移：a >> b
* 无符号右移：a >>> b 

1. 按位与

   规则：两位同时为“1”，结果才为1，否则为0

   0 & 0 = 0；

   0 & 1 = 0；

   1 & 0 = 0；

   1 & 1 = 1；

2. 按位或

   规则：参加运算的两个对象只要一个为1，其为1

   0 | 0 = 0；

   0 | 1 = 1；

   1 | 0 = 1；

   1 | 1 = 1；

   ```java
   public class Main {
    public static void temp(int[] tmp) {
           if (tmp == null || tmp.length == 0) {
    		}           
    }
    
    public static void main(String[] args){
    	int[] nunms = null;
    	temp(nums);
    }
   }
   ```

   上面代码的 `（tmp == null）|| tmp.leng == 0`顺序一定不能反，不然先执行`tmp.length==0`会报错*NullPointerException*. 

3. 按位异或

   规则：相同为零，不同为一

   0 ^ 0 = 0;

   0 ^ 1 = 1;

   1 ^ 0 = 1;

   1 ^ ! = 0;

4. 移位：左移/右移

   1 << 0: 00001 = 1:       1 >> 0: 00001 = 1;

   1 << 1: 00010 = 2;       2 >> 1: 00001 = 1;

   1 << 2: 00100 = 4;        4 >> 1 00010 = 2;

   1 << 3: 01000 = 8;        8 >> 1 00100 = 4; (和除号差不多)    

5. 无符号右移 >>>: 不管正负标志位是0还是1，将该数的二进制码整体右移，左边部分总是以0填充，右边部分舍弃。

   * -5用二进制表示**1**111 1011。第一个1是该数标志位。

     -5 >> 2: **1**111 1011 -> 11**1**1 1110。标志位向右移动了两位。

     -5 >>> 2: **1**111 1011 -> *00* **1**1 1110。前两个*0*作为补充的零，最后两个1舍弃。

   * 没有无符号左移。

## 1.4 编码标准

* 国际标准：ASCⅡ （0-127）

* 扩展的 ASCⅡ （0-255）(一般写`int[256]`)

* 字符集：Unicode (全世界的文字字符集), UTF-8, 中国GB2312

* 算法种的编码：- '0' 或者 -'a'

  ```java
  public static void encode(){
      String s = "abc";
      for (char c : s.toCharArray()){
          System.out.println(c - 'a');
      }
      System.out.println((int)'a');
  }
  ```

​	output:

	```
	 0 // 'a'-'a'
	 1 // 'b'-'a'
	 2 // 'c'-'a'
	 97 // 'a'
	```

​    计算一个字符串中每个字母出现的次数：

```java
 int[] count = new int[256];
        String d = "abc";

        for (char c: d.toCharArray()){
            int res = c - 'a';
            count[c - 'a']++;
            System.out.print(res); // 0, 1, 2
        }
System.out.println();
        for (int i : count) {
            System.out.print(i);
        } // 111000000....(253个0)
```

如果是数字，拿2应该减去0

```java
String digit = "1234";
for (char c : digit.toCharArray()){
    int res = c - '0';
    System.out.print(res);  // 1234
}
```

## 1.5 亦或XOR

* 判断唯一元素

* LeetCode136: Single Number

  Given an array of integers, every element appears twice except for one, Find the single one.

  ```java
  public static int singleNum(int[] num) {
      int res = 0;
      for (int i = 0; i < num.length; i ++) {
          res ^= num[i];  // 将数字转化为ASCⅡ编码，相同位置为0，不同位置为1
      }
      return res;
  }
  ```

* LeetCode 389: Find the Difference

  Given two Strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then *add one more letter at a random position*. Find the letter that was added in t. 

  input:

  ```java
  S = "abcd"
  t = "abcde"
  ```

  output:

  ```java
  e
  ```

  Sol:

  ```java
  // LeetCode 389
  public static int findTheDifference(String s, String t){
      char c = t.charAt(t.length() - 1);
      for (int i = 0; i < s.length(); i++) {
          c ^= s.charAt(i);
          c ^= t.charAt(i);
      }
      return c;
  }
  ```



## 1.6 n & ( n - 1)

+ 判断是2的整数次幂：`n&(n-1) == 0;`  8: 1000, 7: 0111, 8&7 = 0;

  LeetCode 231. Power of Two

  Given a integer, write a function to determine if it is a power of two.

  ```java
  public static boolean isPowerOfTwo(int n ){
      return (n>0) && ((n&(n-1)) == 0);
  }
  ```

+ 最低位为1的改为0: `n &= (n-1);` 9: 1001, 9 & (9-1) = 1001 & 1000 = 1000 

  LeetCode 191. Number of 1 Bits

  Write a function that takes an unsigned integer and returns the number of '1' bits it has.

  ```java
  public static int hammingWeight(int n) {
      int res = 0;
      while(n != 0) {
          n &= (n-1);
          res ++;
      }
      return res;
  }
  ```



## 1.7 n&1

+ 判断奇偶数 n &1 (返回1表示奇数，0表示偶数) 偶数的第0位肯定为零。

+ 末尾取1

  LeetCode191: Number of 1 bits

  ```java
  public static int hammingWeight1(int n ){
      int res = 0;
      for (int i = 0; i < 32; i++) {
          res += n & 1;
          n >>= 1; // 向右移1位
      }
      return res;
  }
  ```

## 1.8 万能Follow Up

* 数据量过大怎么办

  1. 求数组之和，数组元素有1亿个，单机装不下

     Sol1：分机解决，分10台机器，分别存储计算（分布式计算）

     Sol2: BitMap (位图) 

  2. Given an array containing n distinct numbers taken from 0, 1, 2, 3, ...., n, find the one that is missing from the array.

     ```java
     public static int missingNumber(int[] nums){
         int res = nums.length;
         for (int i = 0; i < nums.length; i++) {
             res ^= i ^ nums[i];
         }
         return res;
     }
     ```

* BitMap: 用bit表示每一位数字。`int: 4 byte = 4 * 8 = 32 bit`有多少位就用多少个bit，每个位置的数字对应bitmap上面的一个bit。如果这个位置有数字，bit值为1，如果没有数字bit的值为0。**Int** 类型有32个bit，如果有1亿个数据，就用bitmap来存储数据，就会有1亿/32个bitmap.

  Java表示：BitSet

  + Initialize 的时候是64位的，之后扩容是每次加2^6

  + `BitSet.set(i)`: 将第i位的bit设置为1

  + `BitSet.get(i)`: 得到第i位的数值，true or false

    ```java
    public static void bitSet() {
        BitSet bitSet = new BitSet();
        System.out.println(bitSet.get(0));  // false
        System.out.println(bitSet.size());  // 64
        bitSet.set(0);				       
        System.out.println(bitSet.get(0));  // true
        System.out.println(bitSet.size());  //  64
    
        bitSet.set(65);
        System.out.println(bitSet.get(65));  // true
        System.out.println(bitSet.size());   // 128
    }
    ```
    
    
    
    Implement an algorithm to determine if a string has all unique characters, what if you cannot use additional data structures?
    
    
    
    + ```java
      public static boolean isUniqueChars(String str){
          if (str.length() > 256) {
              return false;
          }
          int checker = 0;
      
          for (int i = 0; i < str.length(); i++) {
              int val = str.charAt(i);  // 将此字符转化成ASC码
              if ((checker & (1 << val)) > 0) {  // 如果任意一个字母的ASC码左移一位与上之前的值大于0就代表此字母之前出现过
                  return false;
              }
              checker |= (1<<val);  // Val 左移一位再或上checker  任何一个不同的字母的ASC码左移一位再或上之前的值该位置都是1
          }
          return true;
      }
      ```



# 2. 数学题

## 2.1  越界

+ LeetCode 7：Reverse Number

Given a signed 32-bit integer `x`, return `x` *with its digits reversed*. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-2^31, 2^31 - 1]`, then return `0`.

Java 种*Integer.Max_Value*  是 2147483647，reverse了过后就是7463847412, 肯定是越界了的。int: 4 byte (-2^31, 2^31-1), long: 8 byte (-2^63, 2^63-1), integer -> long. 

```java
// 必备代码！！！！背下来
long res = 0;
while (x != 0){
    res = res * 10 + x % 10; // 取出个位数，加上原来的数字
    x /= 10;  // 去除个位数字
    if (res > Integer.MAX_VALUE || res < Integer.MIN_VALUE){
        return 0;  //  越界的话return 0;
    }
}
return (int)res;
```

## 2.2   比较处理

```Java
System.out.println(Integer.MAX_VALUE + 2);
```

这一段代码的输出为-2147483647。

如果我们跟之前的数字对比，就会不同，可以利用这一点来解题。

```java
int res = 0;
while (x != 0){
    int cur = res;
    res = res * 10 + x % 10;
    if (res/10 != cur) return 0;
    res = res * 10 + x % 10; // 取出各位数，加上原来的数字
}
return res;
```

## 2.3  进位

从个位相加，最后进位，开辟新空间

加法：末尾开始

leetCode66: Plus one:

ou are given a **large integer** represented as an integer array `digits`, where each `digits[i]` is the `ith` digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s.

ncrement the large integer by one and return *the resulting array of digits*.

```java
public static int[] plusOne(int[] digits){
    if (digits == null || digits.length == 0) {
        return digits;
    }

    for (int i = digits.length - 1; i >= 0; i--) {
        if (digits[i] < 9) {
            digits[i] ++;
            return digits;
        }else {
            digits[i] = 0;
        }
    }
    int[] res = new int[digits.length + 1];  // 999 + 1 = 1000这种情况
    res[0] = 1;
    return res;
}
```

## 2.4  符号，字母

+ 符号：***sign***单独提取，最后处理

+ 字母：`!Character.isDihit(str.charAt(i))`.

+ LeetCode8: String to Integer (Atoi)

  ```java
  // leetCode 8: String to Integer
  class myAtoi{
      public static int myAtoi(String s){
          s = s.trim();
          if (s == null || s.length() == 0){
              return 0;
          }
          char firstChar = s.charAt(0);
          int sign = 1;
          int start = 0;
          long res = 0;
          if (firstChar == '+'){
              start++;
          } else if (firstChar == '-') {
              sign = -1;
              start ++;
          }
          for (int i = start;i < s.length(); i++){
              if (!Character.isDigit((s.charAt(i)))){  // 如果不是数字，直接return
                  return (int) res * sign;
              }
              res = res*10+s.charAt(i) - '0';
              if (sign == 1 && res > Integer.MAX_VALUE) return Integer.MAX_VALUE;  // 判断越界
              if (sign == -1 && res > Integer.MAX_VALUE) return Integer.MIN_VALUE;
          }
          return (int) res*sign;
      }    
  }
  
  ```

## 2.5 开方

Given a **positive** integer *num*, write a function which returns True if *num* is a perfect square else False.

**Follow up:** **Do not** use any built-in library function such as `sqrt`.

 

```java
// 1. 二分法 o(log(n))
public static boolean isPerfectSquare(int num){
    int low = 1;
    int high = num;
    while (low <= high){
        long mid = (high - low) / 2 + low;
        if (mid * mid == num) {
            return true;
        } else if (mid * mid < num) {
            low = (int)mid + 1;
        }else {
            high = (int)mid - 1;
        }
    }
    return false;
}
```

```java
// 2. n*n . num
public static boolean isPerfectSquare1(int num){
    if ((num)< 0) return false;
    if (num == 1) return true;
    for (int i = 1; i <= num / i; i++) {
        if (i * i == num) return true;
    }
    return false;
}
```



<img src="C:\Users\zwh52\AppData\Roaming\Typora\typora-user-images\image-20220615112513296.png" alt="image-20220615112513296" style="zoom:67%;" />

```java
// 3. 牛顿法 （切线法）

public static boolean isPerfectSquare2(int num){
    long x = num;
    while (x * x > num){
        x = (x + num / x) /2;
    }
    return x * x == num;

}
```

# 3. 数组

## 3.1 双指针

数组问题大多数都可以用双指针解决

### 3.1.1 模板一：单向双指针

```java
Object result; // 返回结果 int List String
Object temp； //临时变量，不一定有，看题
for (int i = 0; i < num.length; i ++) {
  // 处理
}

```

+ 区间问题

  1. 按start 排序

  2. 解题技巧：前一个区间 *end* & 后一个区间 *start*

     LeetCode 252: Meeting Rooms

     Given an array of meeting time intercals consisting of start and end times [[s1, e1], [s2, e2, ...]] (si < ei), determine if a person could attend all meetings.

     For example: Given [[0, 30], [5, 10], [15, 20]], return falsel.

     + 按start 排序

     + 解题技巧： 前一个区间 end & 后一个区间  start

       ```java
       public boolean conAttendMeetings(Interval[] intervals) {
       	Arrays.sort(intervals, (x, y) -> x.start - y.start);
       	for (int i = 0; i < interval.length; i ++) {
       		if (interval[i - 1].end > intervals[i].start) {
       			return false;
       		}
       	}
       	return true;
       }
       ```

       

+ 扫描线算法
  1. 在计算机图形学种，多边形填充算法 （Sweep Line）
  
  2. 中心思想：单向扫描
  
     LeetCode 153: Meeting Rooms 2
  
     Given an array of meeting time intervals consisting of start and end times [[s1, e1]. [s2, e2], ...] [si < ei], find the minimum number of conference rooms required.
  
     Example: input: [[0, 30], [5, 10], [15,20]]
  
     ​				output: 2
  
     ```java
     public int minMeetingRooms(Interval[] internals) {
     	int[] starts = new int[intervals.length];
     	int[] ends = new int[intervals.length];
     	for (int i = 0; i < intervals.length; i ++) {
     		start[i] = intervals[i].start;
     		ends[i] = intervals[i].end;
     	}
     	Arrays.sort(starts);
     	Arrays.sort(ends);
     	int end = 0;
     	int res = 0;
     	for (int i= 0; i < intervals.length; i ++) {
     		if(start[i] < ends[end]) {
     			res ++;
     		} else {
     			end ++;
     		}
     	}
     	return res;
     }
     ```
     
  
+ 子数组

  1. 解题技巧：前缀和/前缀积

  2. 处理方式：进行种处理，分段式处理 （能写成进行中就写进行中）

  3. 模板：

     ```java
     for (int i = 1; i < nums.length; i ++ ) {
         nums[i] += nums[i-1]
     }
     ```

     进行中处理：
     
     LeetCode 209: Minimum subarray Sum
     
     Given an array of positive integers `nums` and a positive integer `target`, return the minimal length of a **contiguous subarray** `[numsl, numsl+1, ..., numsr-1, numsr]` of which the sum is greater than or equal to `target`. If there is no such subarray, return `0` instead. (Sliding window)
     
     ```java
     public int minSubArrayLen(int s, int[] nums) {
     	int res = Integer.MAX_VALUE;
     	int left = 0, sum = 0;
     	for (int i = 0; i < nums.length; i ++) {
     		sum += nums[i];
             while(left <= i && sum >= s) {
                 res = Math.min(res, i - left + 1);  // left pointer move right
                 sum -= nums[left++]; // Sliding window
             }
     	}
     	return res == Integer.MAX_VALUE ? 0: res;
     }
     ```
     
     分段式处理：
     
     LeetCode 238: Product of Array Except self:
     
     Given an integer array `nums`, return *an array* `answer` *such that* `answer[i]` *is equal to the product of all the elements of* `nums` *except* `nums[i]`.
     
     The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.
     
     You must write an algorithm that runs in `O(n)` time and without using the division operation.
     
     ```java
     public int[] prodect public int[] productExceptSelf(int[] nums) {
             int[]leftmulti = new int [nums.length];
             int[]rightmulti = new int [nums.length];
             int []answer = new int[nums.length];
             int left = 1;
             int right = 1;
             
             //calculate the product for the left side
             for(int i =0; i< nums.length; i++){
                 leftmulti[i] = left;
                 left *= nums[i];
             }
             
             //calculate the product for the right side
             for(int i = nums.length -1; i >= 0; i--){
                 rightmulti[i] = right ;
                 right *= nums[i];
             }
             
             //multiplying both products together left side * right side
             for(int i = 0; i < nums.length; i++){
                 answer[i] = leftmulti[i] * rightmulti[i];
             }
             return answer;
         }
     ```
  
+ 双指针 (Two Pointer)

  + 数组问题大多都可以用双指针解决

  + 模板2： 双指针：

    ```java
    int left = 0;
    int right = nums.length - 1;
    Object res // 一般结果 int list stirng...
    while(left < right) {
    	//处理
    }
    ```

    LeetCode11: Container with most water

    ![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)

    ```java
    Input: height = [1,8,6,2,5,4,8,3,7]
    Output: 49
    Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
    ```

    Solution:

    ```java
    public int maxArea(int[] height) {
    	int res = 0;
    	int l = 0; r = height.length - 1;
    	while(l < r) {
    		res = Math.max(res, Math.min(height[l], height[r]) * (r - l));
    		if (height[i] < height[r]) {
    			l ++;
    		} else {
    			r --;
    		}
    	}
    	return res;
    }
    ```

+ 二维数组

  1. 左右翻转

  2. 上下翻转

  3. 对角线翻转（主，副）

     ```java
     // 对角线
     public static void diagonal(int[][] matrix) {
     	for(int i = 0; i < matrix.length; i ++) {
     		for (int j = 0; j < i; j ++) {
     			int temp = matrix[i][j];
     			matrix[i][j] = matrix[j][i];
     			matrix[j][i] = temp;
     		}
     	}
     }
     
     // 反对角线
     public static void counterDiagnal(int[][] matrix) {
         int len = matrix.length;
         for(int i = 0; i < len; i ++) {
     		for (int j = 0; j < len - 1- i; j ++) {
     			int temp = matrix[i][j];
     			matrix[i][j] = matrix[len - 1 -j][len - 1- i];
     			matrix[len - 1- j][len - 1- i] = temp;
     		}
     	}
     }
     
     //水平
     public static void horizontal(int[][] matrix) {
         int len = matrix.length;
         for (int i = 0; i < len; i ++) {
             for(int j = 0; j < len; j ++) {
                 int temp = matrix[i][j];
                 matrix[i][j] = matrix[len - 1- i][j];
                 matrix[len - 1 -i][j] = temp;
             }
         }
     }
     
     // 竖直
     public static void vertical(int[][] matrix) {
         int len = matrix.length;
         for (int i = 0; i < len; i ++) {
             for(int j = 0; j < len; j ++) {
                 int temp = matrix[i][j];
                 matrix[i][j] = matrix[i][len - 1 - j];
                 matrix[i][len - 1 -j] = temp;
             }
         }
     }
     ```
     
     
     
     LeetCode 48: Rotate Image
     
     You are given an `n x n` 2D `matrix` representing an image, rotate the image by **90** degrees (clockwise).
     
     You have to rotate the image [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm), which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.
     
      ![img](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)
     
     ```java
     Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
     Output: [[7,4,1],[8,5,2],[9,6,3]]
     ```
     
     Solution:
     
     ```java
     //先对角再竖直
     public static void diagonal(int[][] matrix) {
         
     }
     
     
     ```
     
     LeadCode54: Spiral matrix (原型题背)
     
     Given an `m x n` `matrix`, return *all elements of the* `matrix` *in spiral order*.
     
     ![img](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)
     
     ```java
     Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
     Output: [1,2,3,6,9,8,7,4,5]
     ```
     
     Solution:
     
     ```java
     Public List<Integer> SpiralOrder(int[][] matrix){
     	List<Integer> res = new ArrayList<>();
     	if (matrix == null || matrix.length ==0 || matrix[0] == null || matrix[0].length == 0) {
             return res;
         }
         int rowBegin = 0;
         int rowEnd = matrix.length -1;
         int colBegin = 0;
         int colEnd = matrix[0].length - 1;
         
         while (rowBegin <= rowEnd && colBegin <= colEnd) {
             for(int i = colBegin; i <= colEnd; i ++) {
                 res.add(matrix[rowBegin][i]);
             }
             rowBegin ++;
             for(int i = rowBegin; i <= rowEnd; i ++) {
                 res.add(matrix[i][colEnd]);
             }
             colEnd--;
             
             if(rowBegin <= rowEnd) {
                 for(int i = colEnd; i >= colBegin; i --) {
                    res.add(matrix[rowEnd][i]);
                 }
             }
             rowEnd --;
             
             if(colBegin <= colEnd){
                 for (int i = rowEnd; i >= rowBegin; i --) {
                     res.add(matrix[i][colBegin]);
                 }
             }
             colBegin++;
         }
         return res;
     }
     ```
  
+ 实现题

  假设你是一个专业的狗仔，参加了一个 n 人派对，其中每个人被从 0 到 n - 1 标号。在这个派对人群当中可能存在一位 “名人”。所谓 “名人” 的定义是：其他所有 n - 1 个人都认识他/她，而他/她并不认识其他任何人。

  现在你想要确认这个 “名人” 是谁，或者确定这里没有 “名人”。而你唯一能做的就是问诸如 “A 你好呀，请问你认不认识 B呀？” 的问题，以确定 A 是否认识 B。你需要在（渐近意义上）尽可能少的问题内来确定这位 “名人” 是谁（或者确定这里没有 “名人”）。

  在本题中，你可以使用辅助函数 bool knows(a, b) 获取到 A 是否认识 B。请你来实现一个函数 int findCelebrity(n)。

  派对最多只会有一个 “名人” 参加。若 “名人” 存在，请返回他/她的编号；若 “名人” 不存在，请返回 -1。
  Solution:

  ```java
  public int findCelebrity(int n) {
  	if (n < 2) return -1;
      int res = 0;
      for(int i = 1; i < n; i ++) { // 如果有的话一定会遍历到名人
          if(knows(res, i)) {
              res = i;  // 名人不认识任何人，之前的名人不是了
          }
      }
      
      // 如果名人不存在
      for(int i = 0; i < n; i ++) {
          if(re != i && ((knows(res, i) || !knows(i, res)))) {
              return -1;  // 名人不认识任何人，任何人都认识名人
          }
      }
      return res;
  }
  ```

+ 数学定理

  Moore Voting Algorithm:

  每次找出一对不同的元素，从数组中删掉，直到数组为空或者只剩下一种元素，如果存在元素e出现频率超过一半，那么数组中最后剩下的就只有e。

  LeetCode169: Majority Element

  Given an array `nums` of size `n`, return *the majority element*.

  The majority element is the element that appears more than `⌊n / 2⌋` times. You may assume that the majority element always exists in the array.

  ```java
  Input: nums = [3,2,3]
  Output: 3
  ```

  Solution：

  ```java
  // 暴力解
  public int majorityElement(int[] nums) {
  	Arrays.sort(nums);
  	return nums[nums.length / 2];
  }
  
  // Moore Voting
  public int majorityElementMoore(int[] nums) {
      int count = 0;
      int res = 0;
      for (int num : nums ) {
          if(count == 0) {
              res = nums;
          }
          if(nums != res) {
              count --;
          } 
      }
  }
  ```

  


# 4. 二分查找

+ 数组 “增删改查“的最优解

  1. 必须采用顺序存储结构
  2. 必须按关键字大小有序排列

+ 注意点：

  ```java
  int mid = (right - left) / 2 + left;
  // left + right 可能会溢出问题（大于Integer.MAX_VALUE）
  ```

+ 递归：time: O(logn), space: O(logn)

  ```java
   public static int binarySearch(int[] nums, int low, int high, int target){
          if (high < low) return -1;
          int mid = low + (high - low)/2;
          if (nums[mid] > target) {
              return binarySearch(nums, low, mid - 1, target);
          } else if (nums[mid] < target) {
              return binarySearch(nums, mid + 1, high, target);
          } else {
              return mid;
          }
      }
  ```

  logN 时间复杂度：1. 二分查找 2. PriorityQueue (Heap)
  
+ 迭代：

  1.  迭代写法 <=, `right < target < left`, `right + 1 =left`.

  ```java
  public static int binarySearch(int[] nums, int target) {
  	int left = 0;
      int right = nums.length - 1;  // [left, right]
      while(left <= right) {        // left = right
          int mid = (right - left) / 2 + left;
          if (nums[mid] > target) { // [left, mid - 1]
              right = mid - 1;
          } else if (nums[mid] < target) {  // [mid + 1, right]
              left = mid + 1;
          } else {
              return mid;
          }
      }
      return  -1;
  }
  ```

  2. 迭代写法 <， `target < left = right`, `left = right`.

     ```java
     public static int binarySearch(int[] nums, int target) {
     	int left = 0;
         int right = nums.length;  	 // [left, right) 开区间
         while(left < right) {        // left = right不执行 
             int mid = (right - left) / 2 + left;
             if (nums[mid] > target) { // [left, mid）
                 right = mid;
             } else if (nums[mid] < target) {  // [mid + 1, right）
                 left = mid + 1;
             } else {
                 return mid;
             }
         }
         return  -1;
     }
     ```

  3. 迭代写法 `left + 1 < right`

     ```java
     public static int binarySearch3(int[] nums, int target) {
     	int left = 0;
         int right = nums.length - 1;  	 // [left, right] 闭区间
         while(left + 1 < right) {        // left 和 right 挨在一起时不执行 
             int mid = (right - left) / 2 + left;
             if (nums[mid] > target) { // [left, mid]
                 right = mid;
             } else if (nums[mid] < target) {  // [mid, right]
                 left = mid;
             } else {
                 return mid;
             }
         }
         if (target == nums[left]) {  // 由于left和right挨在一起时不会执行，需要额外判断停止的条件
             return left;
         } else if (target == nums[right]) {
             return right;
         }
         return  -1;
     }
     ```

     *查看LeetCode 81 和  LeetCode 33*
  
+ 数组中的二分查找

  1. **Search**, **Find** 等字眼，涉及“查”， 必定二分查找

  2. 子数组题型：LeetCode 300 (出现次数多)

  3. 一维  -> 二维，二维查找***最优解***必定是二分法

     ```java
     // Leetcode 74 Search Matrix
     
         /**
          * Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix.
          * This matrix has the following properties:
          * <p>
          * Integers in each row are sorted from left to right.
          * The first integer of each row is greater than the last integer of the previous row.
          * <p>
          * Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
          * Output: true
          * <p>
          * Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
          * Output: false
          */
         class SearchMatrix74 {
             public boolean searchMatrix(int[][] matrix, int target) {
                 int row = matrix.length;
                 int col = matrix[0].length;
                 int start = 0;
                 int end = row * col - 1;
     
                 while (start <= end) {
                     int mid = (end - start) / 2 + start;
                     int value = matrix[mid / col][mid % col];  // 当前这个值处于二维数组中的哪里（背下来）
                     if (value == target) {
                         return true;
                     } else if (value < target) {
                         start = mid + 1;
                     } else {
                         end = mid - 1;
                     }
                 }
                 return false;
             }
         }
     ```


# 5. Linked List

1. 链表单独操作

2. 和各种数据结构结合

3. ArrayList **VS** LinkedList

### 5.1 常考题型 1 —— 基本操作

1. 有无头节点: 头节点变动的时候一定会有`dummy` 节点
2. 循环逻辑：不会去写`for`循环，一般用`while`. 
3. 结束条件

```java
// LeetCode 24:
 /**
     *
     * Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without
     * modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)
     *
     *Input: head = [1,2,3,4]
     * Output: [2,1,4,3]
     *
     *Input: head = []
     * Output: []
     *
     */

    class Solution24 {
        public ListNode swapPairs(ListNode head) {
            if (head == null || head.next == null) return head;
            ListNode dummy = new ListNode(0);  // 头节点变了，要用dummy
            dummy.next = head;    // dummy ->  2 -> 1 -> 4 -> 3
            ListNode l1 = dummy;  // dummy ->  1 -> 2 -> 3 -> 4
            ListNode l2 = head;   //   ^       ^
                                  //   l1      l2                               //  l1 l2
            while (l2 != null && l2.next != null) {                             //   _______
                ListNode nextStart = l2.next.next;                              //  |       |
                l1.next = l2.next;  // 将dummy的下一个节点设为l2的下一个 画图画出来就理解了 d  1 -> 2 -> 3
                l2.next.next = l2;  // 将l2的下一个接在dummy后面
                l2.next = nextStart;
                l1 = l2;
                l2 = l2.next;
            }
            return dummy.next;
        }
    }
```

LeetCode 238: Odd Even LinkedList:

Given the `head` of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return *the reordered list*.

The **first** node is considered **odd**, and the **second** node is **even**, and so on.

Note that the relative order inside both the even and odd groups should remain as it was in the input.

You must solve the problem in `O(1)` extra space complexity and `O(n)` time complexity.

```java
class Solution {
    public ListNode oddEvenList(ListNode head) {
         if (head == null || head.next == null) return head;
            ListNode odd = head;
            ListNode even = head.next;
            ListNode evenHead = even;
            while (even != null && even.next != null) {
                odd.next = odd.next.next;
                even.next = even.next.next;
                odd = odd.next;
                even = even.next;
            }
            odd.next = evenHead;
            return head;
    }
}
```

## 5.1 翻转

+ LeetCode 206：
	 Given the head of a singly linked list, reverse the list, and return the reversed list.


  ```java
  class Solution206 {  // 背下来
          public ListNode reverseList(ListNode head) {
              if (head == null || head.next == null) return head;
              ListNode pre = null;
              while (head != null) {
                  ListNode temp = head.next;
                  head.next = pre;
                  pre = head;
                  head = temp;
              }
              return pre;
          }
      }
  ```

+ LeetCode: 92: Reverse LinkedList II

  Given the head of a singly linked list and two integers left and right where `left <= right`, reverse the nodes of the list from position left to position right, and return the reversed list.
  
  ```
  Input: head = [1,2,3,4,5], left = 2, right = 4
  Output: [1,4,3,2,5]
  ```
  
  ```
  Input: head = [5], left = 1, right = 1
  Output: [5]
  ```
  
  Sol:
  
  ```java
  class Solution {
      public ListNode reverseBetween(ListNode head, int m, int n) {
           ListNode dummy = new ListNode(0);
              dummy.next = head;
              ListNode pre = dummy;
              ListNode cur = dummy.next;
              
              for (int i = 1; i < m; i++) {
                  cur = cur.next;
                  pre = pre.next;
              }
              for (int i = 0; i < n - m; i++) {
                  ListNode temp = cur.next;
                  cur.next = temp.next;
                  temp.next = pre.next;
                  pre.next = temp;
              }
              return dummy.next;
      }
  }
  ```

## 5.2 环

+ LeetCode 141: Linked List Cycle

  Given a Linked List, determine if it has a cycle in it.

  ```java
   // 快慢指针解决
      public boolean hasCycle(ListNode head) {
          if (head == null) return false;
          // 快慢两个指针 
          // 如果有环，快指针和慢指针一定会相遇
          ListNode slow = head, fast = head;
          while (fast != null && fast.next != null) {
              slow = slow.next;
              fast = fast.next.next;
              if (slow == fast) return true;
          }
          return false;
      }
  ```

+ LeetCode 142: Linked List Cycle II

  Given the `head` of a linked list, return *the node where the cycle begins. If there is no cycle, return* `null`.

  There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to (**0-indexed**). It is `-1` if there is no cycle. **Note that** `pos` **is not passed as a parameter**.

  **Do not modify** the linked list.

  ```
  Input: head = [3,2,0,-4], pos = 1
  Output: tail connects to node index 1
  Explanation: There is a cycle in the linked list, where tail connects to the second node.
  ```

  ```
  Input: head = [1,2], pos = 0
  Output: tail connects to node index 0
  Explanation: There is a cycle in the linked list, where tail connects to the first node.
  ```

  Sol:

  通过快慢指针可以判断一个链表是否有环。如果有环，那么**快指** 

  **针走过的路径就是图中a+b+c+b**，**慢指针走过的路径就是图中a+b**，因为在相同的时 间内，快指针走过的路径是慢指针的2倍，所以这里有`a+b+c+b=2* (a+b)`，整理得到 `a=c`，也就是说图中a的路径长度和c的路径长度是一样的。 

  ![LinkedListCycle](C:\zwh\Documents\myBlog\LinkedListCycle.png)

  在相遇的时候再使用两个指针，一个从链表起始点开始，一个从相遇点开始，每次他们 都走一步，直到再次相遇，那么这个相遇点就是环的入口。

  ```java
  public class Solution {
      public ListNode detectCycle(ListNode head) {
           if (head == null || head.next == null) return null;
              ListNode slow = head;
              ListNode fast = head;
  
              while (fast != null && fast.next != null) {
                  slow = slow.next;
                  fast = fast.next.next;
                  if (fast == slow) {
                      ListNode slow2 = head;
                      while (slow != slow2) {
                          slow = slow.next;  // 第二个指针从源头开始走直到和慢指针相遇
                          slow2 = slow2.next;
                      }
                      return slow;
                  }
              }
              return null;
      }
  }
  ```


## 5.5 删除

+ LeetCode 237: Delete Node in a Linked List

  Write a function to **delete a node** in a singly-linked list. You will **not** be given access to the `head` of the list, instead you will be given access to **the node to be deleted** directly.

  It is **guaranteed** that the node to be deleted is **not a tail node** in the list.

  ```
  Input: head = [4,5,1,9], node = 5
  Output: [4,1,9]
  Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.
  ```

  ```
  Input: head = [4,5,1,9], node = 1
  Output: [4,5,9]
  Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.
  ```

  Sol:

  ```java
  class Solution {
      public void deleteNode(ListNode node) {
            if (node == null) return;
              node.val = node.next.val;
              node.next = node.next.next;
      }
  }
  ```

+ LeetCode 83: Remove Duplicates from Sorted List

  Given the `head` of a sorted linked list, *delete all duplicates such that each element appears only once*. Return *the linked list **sorted** as well*.

  ```
  Input: head = [1,1,2]
  Output: [1,2]
  ```

  ```
  Input: head = [1,1,2,3,3]
  Output: [1,2,3]
  ```

  Sol:

  ```java
  class Solution {
      public ListNode deleteDuplicates(ListNode head) {
          if (head == null || head.next == null) return head;
              ListNode cur = head;
              while (cur.next != null) {
                  if (cur.next.val == cur.val) { //如果当前节点的值和下一个节点的值相同，就把下一个节点值给删除
                      cur.next = cur.next.next;
                  } else {  //否则cur就往后移一步
                      cur = cur.next;
                  }
              }
              return head; 
      }
  }
  ```
  

# 6. Random

## 6.1 等概率抽取法

问题：如何等概率地从n个数中随机抽取m个数？

+ 缺点1：m接近n, 出现重复的次数增多
+ 缺点2：n必须知道

已有`x`个数，随机生成`x+1`个数的概率：

1次生成该数的概率：`1-x/n`

2次生成该数的概率：`(x/n) * (1 - x/n)`

......

n 次生成该数的概率：`(x/n)^(n - 1) * (1 - x/n)`.

## 6.2 LeetCode中的等概率抽取法

```java
Random rmd = new Random();
int random = md.nextInx(bound);
```

+ LeetCode 398: Random Pick Index

  Given an integer array `nums` with possible **duplicates**, randomly output the index of a given `target` number. You can assume that the given target number must exist in the array.

  Implement the `Solution` class:

  - `Solution(int[] nums)` Initializes the object with the array `nums`.
  - `int pick(int target)` Picks a random index `i` from `nums` where `nums[i] == target`. If there are multiple valid i's, then each index should have an equal probability of returning.

  ```java
  Input
  ["Solution", "pick", "pick", "pick"]
  [[[1, 2, 3, 3, 3]], [3], [1], [3]]
  Output
  [null, 4, 0, 2]
  Explanation:
  Solution solution = new Solution([1, 2, 3, 3, 3]);
  solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.
  solution.pick(1); // It should return 0. Since in the array only nums[0] is equal to 1.
  solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.
  ```

  Solution:

  ```java
  class Solution398 {
   int[] nums;
          Random random;
  
          public Solution398(int[] nums) {
              this.nums = nums;
              this.random = new Random();
          }
  
          public int pick(int target) {
              List<Integer> list = new ArrayList<>();
              for (int i = 0; i < nums.length; i++) {
                  if (nums[i] == target) {
                      list.add(i);
                  }
              }
              return list.get(random.nextInt(list.size()));
          }
  }
  
  /**
   * Your Solution object will be instantiated and called as such:
   * Solution obj = new Solution(nums);
   * int param_1 = obj.pick(target);
   */
  ```

+ LeetCode 380: 

  Implement the `RandomizedSet` class:

  - `RandomizedSet()` Initializes the `RandomizedSet` object.
  - `bool insert(int val)` Inserts an item `val` into the set if not present. Returns `true` if the item was not present, `false` otherwise.
  - `bool remove(int val)` Removes an item `val` from the set if present. Returns `true` if the item was present, `false` otherwise.
  - `int getRandom()` Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the **same probability** of being returned.

  You must implement the functions of the class such that each function works in **average** `O(1)` time complexity.

  ```java
  Input
  ["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
  [[], [1], [2], [2], [], [1], [2], []]
  Output
  [null, true, false, true, 2, true, false, 2]
  
  Explanation
  RandomizedSet randomizedSet = new RandomizedSet();
  randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.
  randomizedSet.remove(2); // Returns false as 2 does not exist in the set.
  randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].
  randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.
  randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].
  randomizedSet.insert(2); // 2 was already in the set, so return false.
  randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.
  ```

  Solution:

  ```java
  class RandomizedSet {
  
          Random rmd;
          ArrayList<Integer> list;
          HashMap<Integer, Integer> map;
  
          public RandomizedSet() {
              this.rmd = new Random();
              this.map = new HashMap<>();  // 将arrayList的index存入 map, 形成index 和数字的键值对
              this.list = new ArrayList<>();
          }
  
          public boolean insert(int val) {
              if (map.containsKey(val)) return false;
              map.put(val, list.size());
              list.add(val);
              return true;
          }
  
          public boolean remove(int val) {
              if (!map.containsKey(val)) return false;
              int index = map.remove(val);
              int lastVal = list.remove(list.size() - 1);  //删除最后一个元素
              if (index != list.size()) {
                  list.set(index, lastVal);
                  map.put(lastVal, index);
              }
              return true;
          }
  
          public int getRandom() {
              return list.get(rmd.nextInt(list.size()));
          }
  }
  
  /**
   * Your RandomizedSet object will be instantiated and called as such:
   * RandomizedSet obj = new RandomizedSet();
   * boolean param_1 = obj.insert(val);
   * boolean param_2 = obj.remove(val);
   * int param_3 = obj.getRandom();
   */
  ```

+ 蓄水池抽样

  从`n`个元素中随机抽取m个元素，但个数无法事先确定

  

  再实际应用中，往往会遇到很大数据流的情况，因此我们无法先保存整个数据流再从中选取，而是期望有一种将数据流遍历一遍就得到所选取的元素，并且保证得到的元素是随机的算法。

  + 从n 个对象中选择一个对象，但是在此之前你是不知道n的值

    解法：总是选择第一个对象，以1/2的概率选择第二个，以1/3的概率选择第三个.......以1/m的概率选择第m个对象。
    
  + 从n个元素中随机抽取m个元素：
  
    解法：前m个元素放入蓄水池，当到第k个（K > m ）时，按照 m/k的概率选中，以均等的概率去替换蓄水池中的先前被选中的任一元素。
  
    优点：不需要用数据结构去存储
  
    用法：数据流（stream）
  
    例子：给一个数据流（stream），等概率取m个数
  
    ```java
    public int[] reservairSampling(int[] stream, int k) {
    	Random rmd = new Random();
    	int[] res = new int[k];
    	
    	for(int i = 0; i < k; i ++) {
    		res[i] = stream[i];
    	}
    	
    	for(int i = k; i < stream.length; i++) {
    		int random = rmd.nextInt(i + 1);
    		if (random < k) {  // 以 k/i 的概率交换
            res[random] = stream[i];
    		}
    	}
    	return res;
    }
    ```

# 7. Stack

## 7.1 题型1：平衡符号

+ Parentheses "{}[]()".

+ 单独题型，非常典型

  ```java
  // LeetCode 20: Valid Parentheses
      /**
       * Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
       *
       * An input string is valid if:
       *
       * 1.Open brackets must be closed by the same type of brackets.
       * 2.Open brackets must be closed in the correct order.
       *
       * Input: s = "()"
       * Output: true
       *
       * Input: s = "()[]{}"
       * Output: true
       *
       * Input: s = "(]"
       * Output: false
       */
  
      class Solution20 {
          public boolean isValid(String s) {
              if (s == null || s.length() == 0) return true;
              Stack<Character> stack = new Stack<>();
              for(Character ch: s.toCharArray()) {
                  if (ch == '(') stack.push(')');
                  else if (ch == '[') stack.push(']');
                  else if (ch == '{') stack.push('}');
                  else {
                      if (stack.isEmpty() || stack.pop() != ch) return false;
                  }
              }
              return stack.isEmpty();
          }
      }
  ```

## 7.2 压栈匹配

1. 前后顺序相关联

2. 有特殊字符“[]....” 或字母代表特殊意义

3. 小模板：

   ```java
   while / For(){
   	if()
   	else if ()
   	else if ()
   	else{}
   }
   ```

   

   LeetCode 394： Decode String

   Given an encoded string, return its decoded string.

   The encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer.

   You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, `k`. For example, there will not be input like `3a` or `2[4]`.

   The test cases are generated so that the length of the output will never exceed `105`.

   ```
   Input: s = "3[a]2[bc]"
   Output: "aaabcbc"
   
   Input: s = "3[a2[c]]"
   Output: "accaccacc"
   ```

   Solution:

   ```java
   class Solution394{
           public String decodeString(String s) {
               if (s == null || s.length() == 0) {
                   return s;
               }
               Stack<Integer> numStack = new Stack<>();
               Stack<String> resStack = new Stack<>();
               String res = "";
               int idx = 0;
               while (idx < s.length()){
                   if (Character.isDigit(s.charAt(idx))){
                       int num = 0;
                       while (Character.isDigit(s.charAt(idx))) {
                           num = num * 10 + s.charAt(idx) - '0';
                           idx++;
                       }
                       numStack.push(num);
                   } else if (s.charAt(idx) == '[') {
                       resStack.push(res);
                       res = "";
                       idx++;
                   } else if (s.charAt(idx) == ']') {
                       StringBuilder temp = new StringBuilder(resStack.pop());
                       int time = numStack.pop();
                       for (int i = 0; i < time; i++) {
                           temp.append(res);
                       }
                       res = temp.toString();
                       idx++;
                   } else {
                       res += s.charAt(idx++);
                   }
   
               }
               return res;
           }
       }
   ```

## 7.3 表达式计算

1. 正常计算：`a + b * c`.

2. 逆波兰式表达法（后缀表达式）：`abc * +`.

   LeetCode  224: Basic Calculator

   Given a string `s` representing a valid expression, implement a basic calculator to evaluate it, and return *the result of the evaluation*.

   **Note:** You are **not** allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.

   ```
   Input: s = "1 + 1"
   Output: 2
   
   Input: s = " 2-1 + 2 "
   Output: 3
   ```

   Solution:

   ```java
   class Solution {
       public int calculate(String s) {
             Stack<Integer> stack = new Stack<>();
               int sign = 1;
               int res = 0;
               for (int i = 0; i < s.length(); i++) {
                   if (Character.isDigit(s.charAt(i))) {
                       int num = s.charAt(i) - '0';
                       while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1))) {
                           num = num * 10 + s.charAt(i + 1) - '0';
                           i ++;
                       }
                       res += num * sign;
                   } else if (s.charAt(i) == '+') {
                       sign = 1;
                   } else if (s.charAt(i) == '-') {
                       sign = -1;
                   } else if (s.charAt(i) == '(') {  // 遇到（，push所有算过的值放入stack，符号位也放进去
                       stack.push(res);
                       stack.push(sign);
                       res = 0;
                       sign = 1;
                   } else if (s.charAt(i) ==')') {
                       res = res * stack.pop() + stack.pop();
                   }
               }
               return res;
       }
   }
   ```

   LeetCode 150: （后缀表达式）Evaluate Reverse Polish Notation

   valuate the value of an arithmetic expression in [Reverse Polish Notation](http://en.wikipedia.org/wiki/Reverse_Polish_notation).

   Valid operators are `+`, `-`, `*`, and `/`. Each operand may be an integer or another expression.

   **Note** that division between two integers should truncate toward zero.

   It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.

   ```
   Input: tokens = ["2","1","+","3","*"]
   Output: 9
   Explanation: ((2 + 1) * 3) = 9
   
   Input: tokens = ["4","13","5","/","+"]
   Output: 6
   Explanation: (4 + (13 / 5)) = 6
   ```

   Solution:

   ```java
   class Solution {
       public int evalRPN(String[] tokens) {
           Stack<Integer> stack = new Stack<>();
               for (String s : tokens) {
                   if (s.equals("+")) {
                       stack.push(stack.pop() + stack.pop());
                   } else if (s.equals("-")) {
                       int b = stack.pop();
                       int a = stack.pop();
                       stack.push(a - b);
                   } else if (s.equals("*")) {
                       stack.push(stack.pop() * stack.pop());
                   } else if (s.equals("/")) {
                       int b = stack.pop();
                       int a = stack.pop();
                       stack.push(a / b);
                   } else {  // 当前的是数字
                       stack.push(Integer.parseInt(s));
                   }
               }
               return stack.pop();
       }
   }
   ```


## 7.4 迭代极值

+ 最近比较后，求最优解
+ 与动态规划不同点：单独拿出来也可以

    LeetCode 42: Trapping rain water

    Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.

    ![TrappingRainWater](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)

    ```
    Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
    Output: 6
    Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
    ```

    LeetCode 84: Largest Rectangle in Histogram

    Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return *the area of the largest rectangle in the histogram*.
    
    ![84](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

	```
	Input: heights = [2,1,5,6,2,3]
	Output: 10
	Explanation: The above is a histogram where width of each bar is 1.
	The largest rectangle is shown in the red area, which has an area = 10 units.
	```
	Solution:
	
	```java
	class Solution {
	    public int largestRectangleArea(int[] heights) {
	            if (heights == null || heights.length == 0) return 0;
	                Stack<Integer> stack = new Stack<>();
	                int res = 0;
	                for (int i = 0; i <= heights.length; i ++) {
	                    int hi = i == heights.length ? 0 : heights[i];
	                    while (!stack.isEmpty() && hi < heights[stack.peek()]) {
	                        int height = heights[stack.pop()];
	                        int start = stack.isEmpty() ? -1 : stack.peek();
	                        int area = height * (i - start - 1);
	                        res = Math.max(res, area);
	                    }
	                    stack.push(i);
	                }
	                return res;
	    }
	}
	```
	
	小模板：
	
	```java
	Stack<OBJ> stack = new Stack<>();
	for / while () {
		for / while (isEmpty() && 条件) {
			内部操作（取Math.min/max, push/pop）
		}
		内部操作 push/pop
	}
	```
	
	

​    

# 8. String

## 8.1 String 基本函数

1. Length()
2. equals()
3. subString()
4. indexOf()
5. lastIndexOf()
6. startsWith()
7. toCharArray()
8. charAt()
9. split()
10. trim()

字符串四重奏：

1. SubString
2. Palindrome
3. Parentheses
4. Subsequence

## 8.2 函数的时间复杂度

1. subString(): 时间复杂度：O(n)

2. indexOf() / lasdtIndexOf(): 时间复杂度：O(n * m) where n is length of the text and m is a length of them.

3. startWith(): o(n)

   + LeetCode28: Implement strStr()

     Given two strings `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`.

     **Clarification:**

     What should we return when `needle` is an empty string? This is a great question to ask during an interview.

     For the purpose of this problem, we will return 0 when `needle` is an empty string. This is consistent to C's [strstr()](http://www.cplusplus.com/reference/cstring/strstr/) and Java's [indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)).

     ```
     Input: haystack = "hello", needle = "ll"
     Output: 2
     ```

     ```
     Input: haystack = "aaaaa", needle = "bba"
     Output: -1
     ```

     Solution:

     ```java
      class Solution28 {
             public int strStr(String haystack, String needle) {
                 if (needle == null || needle.length() == 0) return 0;
                 for (int i = 0; i < haystack.length(); i++) {
                     if (i + needle.length() > haystack.length()) break;
                     for (int j = 0; j < needle.length(); j++) {
                         if (haystack.charAt(i + j) != needle.charAt(j)) break;
                         if (j == needle.length() - 1) return i;
                     }
                 }
                 return -1;
             }
     }
     ```

   + LeetCode 14: Longest Common prefix

     Write a function to find the longest common prefix string amongst an array of strings.

     If there is no common prefix, return an empty string `""`.

     ```
     Input: strs = ["flower","flow","flight"]
     Output: "fl"
     ```

     Solution:

     ```java
     class Solution14{
             public String longestCommonPrefix(String[] strs) {
                 if (strs == null || strs.length == 0) return "";
                 for (int i = 0; i < strs[0].length(); i ++) {  // 将第一个单词的字母拿出来一个接着一个遍历
                     char c = strs[0].charAt(i);
                     for (int j = 1; j < strs.length; j++) {  // 将接着的字符串的相应位置的字母拿去和第一个字母的对应位置比较
                         if (i == strs[j].length() || strs[j].charAt(i) != c ) {
                             return strs[0].substring(0, i);
                         }
                     }
                 }
                 return strs[0];  // 如果第一个单词遍历完了，直接输出第一个单词
             }
         }
     ```

## 8.3 正则表达式

用来检索和替换字符串中的内容

+ +：匹配前面的子表达式一次或多次（大于等于1次）。例如，“zo+”能匹配“zo” 以及“zoo”, 但不能匹配"z".

+ ?：匹配前面的子表达式0次或者一次。例如"do(es)?"可以匹配"do" 或者"does".

+ 常用正则表达式：

  + `String str = s.split(" ");`  分隔单个空格

  + `String str = s.split("\\s+");`  分隔多个空格

  + `String str = s.split("\\.");`   分隔`.`正则表达式中`.`代表任意字符，这时需要\\\来

  + `String str = s.split(",");`   分隔`,`

  + `String str = s.split("/+");` 分隔 `/`

    + LeetCode 165: Compare Version numbers

      Given two version numbers, `version1` and `version2`, compare them.

      

      Version numbers consist of **one or more revisions** joined by a dot `'.'`. Each revision consists of **digits** and may contain leading **zeros**. Every revision contains **at least one character**. Revisions are **0-indexed from left to right**, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example `2.5.33` and `0.1` are valid version numbers.

      To compare version numbers, compare their revisions in **left-to-right order**. Revisions are compared using their **integer value ignoring any leading zeros**. This means that revisions `1` and `001` are considered **equal**. If a version number does not specify a revision at an index, then **treat the revision as `0`**. For example, version `1.0` is less than version `1.1` because their revision 0s are the same, but their revision 1s are `0` and `1` respectively, and `0 < 1`.

      *Return the following:*

      - If `version1 < version2`, return `-1`.
      - If `version1 > version2`, return `1`.
      - Otherwise, return `0`.

      ```
      Input: version1 = "1.01", version2 = "1.001"
      Output: 0
      Explanation: Ignoring leading zeroes, both "01" and "001" represent the same integer "1".
      ```

      ```
      Input: version1 = "1.0", version2 = "1.0.0"
      Output: 0
      Explanation: version1 does not specify revision 2, which means it is treated as "0".
      ```

      Solution:

      ```java
      class Solution {
          public int compareVersion(String version1, String version2) {
                String[] v1 = version1.split("\\.");
                  String[] v2 = version2.split("\\.");
                  for (int i = 0; i < Math.max(v2.length, v1.length); i ++) {
                      int num1 = i < v1.length ? Integer.parseInt(v1[i]) : 0;
                      int num2 = i < v2.length ? Integer.parseInt(v2[i]) : 0;
                      if (num1 < num2) return -1;
                      else if (num1 > num2) return 1;
                  }
                  return 0;
          }
      }
      ```

      

## 8.4 转义字符 & 通配符

+ 转义字符：所有的ASCII 码都可以用`\`加数字（一般是8进制数字）来表示。而C中定义了一些字母前加`“\”`来表示常见的那些不能显示的ASCII的字符，如 `\0, \t, \n ` 等，就是转义字符，以为后面的字符，都不是它本来的ASCII字符意思了。字符串中一个`\`·会自动识别为转义字符，如果要表示`\`本省，需要写成`\\`
+ 通配符 (wildcard): 代替一个或者多个真正字符 （星号`*` 和 问号`?`）

    ## 8.5 String Vs. StringBuilder Vs. StringBuffer

+ leetCode 168: Excel Sheet Column Title

  Given an integer `columnNumber`, return *its corresponding column title as it appears in an Excel sheet*.

  For example:

  ```
  A -> 1
  B -> 2
  C -> 3
  ...
  Z -> 26
  AA -> 27
  AB -> 28 
  ...
  Input: columnNumber = 1
  Output: "A"
  Input: columnNumber = 28
  Output: "AB"
  ```

  Solution:

  ```java
   class Solution168{
          public String convertToTitle(int columnNumber) {
              StringBuilder sb = new StringBuilder();
              while (columnNumber > 0) {
                  columnNumber--;
                  sb.append((char)('A' + columnNumber % 26));
                  columnNumber /= 26;
              }
              return sb.reverse().toString();
          }
      }
  ```

+ String: 字符串常量，对象一经创建后该对象不可更改
+ 对String对象的任何改变都不影响到原对象，相关的任何change操作都会产生新的对象
+ StringBuilder：对象是变量，可以更改
+ StringBuilder是线程不安全的，而StringBuffer是线程安全的
+ StringBuffer很多方法可以带有synchronized关键字

## 8.6 常考题型1：Anagram

相同字母异序词

做法：count sort

小模板：

```java
int[] count = new int[26];
for(int i = 0; i < s.length(); i ++) {
	count[s.charAt(i) - 'a'] ++;
}3
```

LeetCode 242: Valid Anagram

Given two strings `s` and `t`, return `true` *if* `t` *is an anagram of* `s`*, and* `false` *otherwise*.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

Input: s = "anagram", t = "nagaram"
Output: true

```java
	 public boolean isAnagram(String s, String t) {
       if(s.length()!=t.length()) return false; // anagrams always have equal length
    // make an array to store frequency of characters (total 26 characters in the alphabet)
    int[] fmap = new int[26];     
    
    // loop through the strings because now they have equal length and store the frequency of characters of string s as positive 
	// and frequency of string t characters as negative and if they are anagrams 
	// then frequencies should cancel out each other and should be zero at every index.
    for(int i = 0; i<s.length(); i++){
        char c1 = s.charAt(i);
        char t1 = t.charAt(i);
        fmap[c1 - 'a']++;
        fmap[t1 - 'a']--;
    }
    // if there is any value that is not zero then return false immediately
    for(int val: fmap)
        if(val!=0) return false;
    
    // return true if it safely came out of the loop
    return true;       
}
```

## 8.7  常考题型SubString

+ Sliding window

  模板：

  ```java
  for(int i = 0; i < s.length(); i++) {
  	while(){
  		j++;
  	}
  }
  ```

  

+ 双指针，一前一后

  LeetCode 76: minimum window subString

  Given two strings `s` and `t` of lengths `m` and `n` respectively, return *the **minimum window substring** of* `s` *such that every character in* `t` *(**including duplicates**) is included in the window. If there is no such substring**, return the empty string* `""`*.*

  The testcases will be generated such that the answer is **unique**.

  A **substring** is a contiguous sequence of characters within the string.

  ```
  Input: s = "ADOBECODEBANC", t = "ABC"
  Output: "BANC"
  Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
  ```

  Solution:

  ```java
   // 用数组来记录每个字母出现的次数
      public String minWindow1(String s, String t) {
          int[] map = new int[128];
          for (char c : t.toCharArray()) {
              map[c]++;  // 记录字符串t中每个字符的数量
          }
          int count = t.length();
          int left = 0;  // 窗口左边界
          int right = 0;  // 窗口右边界
          int minWindowLen = Integer.MAX_VALUE;  // 覆盖t的最小长度
          int strStart = 0;  // 覆盖字符串t的开始位置
          while (right < s.length()) {
              if (map[s.charAt(right++)]-- > 0) count--;  // 如果找到一个在t中的字符，count减一
              while (count == 0) {  // 如果全部覆盖
                  if (right - left < minWindowLen) {  // 如果有更小的窗口就更新窗口
                      minWindowLen = right - left;
                      strStart = left;
                  }
                  if (map[s.charAt(left++)]++ == 0) {  // 移除最左的元素，左指针向右走
                      count++;
                  }
              }
          }
          if (minWindowLen != Integer.MAX_VALUE) {
              return s.substring(strStart, strStart + minWindowLen);
          }
          return "";
      }
      /*
      总结：滑动窗口类型的题也是最常见的，一般会有两个指针，分别指向窗口的左边界和右边界，
      如果窗口不满足条件我们就移动右边界来扩大窗口，如果满足条件我们可以移动左边界来
      缩小窗口，确定这个更小的窗口是否还满足条件……
       */
  ```

## 8.8 常考题型3 - Parentheses

+ 求单一结果：Stack

+ 求多个结果：Backtracking + Recusion

  LeetCode 32: Longest Valid Parentheses

  Given a string containing just the characters `'('` and `')'`, find the length of the longest valid (well-formed) parentheses substring.

  ```
  Input: s = "(()"
  Output: 2
  Explanation: The longest valid parentheses substring is "()".
  ```

  ```
  Input: s = ")()())"
  Output: 4
  Explanation: The longest valid parentheses substring is "()()".
  ```
  
  Solution:
  
  ```java
   class Solution32 {
          public int longestValidParentheses(String s) {
              Stack<Integer> stack = new Stack<>();
              int res = 0, j = -1;
              for (int i = 0; i < s.length(); i++) {
                  if (s.charAt(i) == '(') stack.push(i);
                  else{  
                      if (stack.isEmpty()) j = i;  // 一开始就遇到（
                      else {
                          stack.pop();
                          if (stack.isEmpty()) res = Math.max(res, i - j);
                          else res = Math.max(res, i - stack.peek());
                      }
                  }
              }
              return res;
          }
      }
  ```

## 8.9 常考题型：Palindrome

+ 求单一结果String：正常for循环

+ 求单一结果个数：动态规划

+ 求多个结果：Backtracking + Recursion

+ 模板：

  ```java
  private boolean isPalindrome(String s) {
  	int left = 0;
  	int right = s.length() - 1;
  	whiile(left < right) {
  		if(s.charAt(left) != s.charAt(right)) {
  			return false;
  		}
  	left ++;
  	right --;
  	}
  	return true;
  }
  ```

## 8.10 常考题型5：SubSequence

+ 以单一数位结果：动态规划

+ 最难的题型之一

+ # [392\. Is Subsequence](https://leetcode.com/problems/is-subsequence/submissions/)

  ## Description

  Difficulty: **Easy**  

  Related Topics: [Two Pointers](https://leetcode.com/tag/two-pointers/), [String](https://leetcode.com/tag/string/), [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)


  Given two strings `s` and `t`, return `true` _if_ `s` _is a **subsequence** of_ `t`_, or_ `false` _otherwise_.

  A **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `"ace"` is a subsequence of `"<u>a</u>b<u>c</u>d<u>e</u>"` while `"aec"` is not).

  **Example 1:**

  ```
  Input: s = "abc", t = "ahbgdc"
  Output: true
  ```

  **Example 2:**

  ```
  Input: s = "axc", t = "ahbgdc"
  Output: false
  ```

  **Constraints:**

  *   `0 <= s.length <= 100`
  *   0 <= t.length <= 10<sup>4</sup>
  *   `s` and `t` consist only of lowercase English letters.

  **Follow up:** Suppose there are lots of incoming `s`, say s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub> where k >= 10<sup>9</sup>, and you want to check one by one to see if `t` has its subsequence. In this scenario, how would you change your code?

  ## Solution

  Language: **Java**

  ```java
  class Solution {
      public boolean isSubsequence(String s, String t) {
                      if (s == null || s.length() == 0) return true;
              int i = 0, j = 0;
              while (i < s.length() && j < t.length()) {
                  if (s.charAt(i) == t.charAt(j)) i++;
                  j++;
              }
              return i == s.length();
      }
  }
  ```

## 8.11 常考题型6：实现题

+ 从最简单到最难
+ 最常考：边界条件

# 9. 图形题

1. 点，线，面
2. 除了特殊算法，不涉及任何数据结构（HashMap除外）
3. 属于最难的题之一
4. 计算机图形学

## 9.1 题型

![image-20220713140200200](C:\zwh\Documents\myBlog\图形题型)

## 9.2 点

### 9.2.1 点在线段上

1. 点 O 是否在所在的直线（A, B）上，带入点到直线方程，算x轴的范围

   不要轻易算斜率！

2. 两点式：(y -y1)/(y2 - y1) = (x -x1)/(x2 - x1) (x1 ≠ x2, y1 ≠ y2)

### 9.2.2 向量

1. A X B = A.x * B.y - A.y * B.x

## 9.3 方向

![image-20220713145616793](C:\zwh\Documents\myBlog\图形方向)

## 9.4 点在直线上

# [149\. Max Points on a Line](https://leetcode.com/problems/max-points-on-a-line/submissions/)

## Description

Difficulty: **Hard**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Math](https://leetcode.com/tag/math/), [Geometry](https://leetcode.com/tag/geometry/)


Given an array of `points` where points[i] = [x<sub>i</sub>, y<sub>i</sub>] represents a point on the **X-Y** plane, return _the maximum number of points that lie on the same straight line_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg)

```
Input: points = [[1,1],[2,2],[3,3]]
Output: 3
```

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg)

```
Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
Output: 4
```

**Constraints:**

*   `1 <= points.length <= 300`
*   `points[i].length == 2
*   -10<sup>4</sup> <= x<sub>i</sub>, y<sub>i</sub> <= 10<sup>4</sup>
*   All the points` are **unique**.


## Solution

Language: **Java**

```java
class Solution {
    
   
    public int maxPoints(int[][] points) {
            if (points == null || points.length == 0) return 0;
            if (points.length < 2) return points.length;
            int res = 0;

            for (int i = 0; i < points.length; i ++) {
                HashMap<String, Integer> map = new HashMap<>();  // 用hashmap来记录点和对应的斜率
                int samePoint = 0;
                int sameXAxis = 1;
                for (int j = 0; j < points.length; j++) {
                    if (i != j) {
                        if (points[i][0] == points[j][0] && points[i][1] == points[j][1]) {
                            samePoint++;
                        }
                        if (points[i][0] == points[j][0]) {
                            sameXAxis++;  // x = x的时候不能计算斜率
                            continue;
                        }
                        int numerator = points[i][1] - points[j][1];
                        int denominator = points[i][0] - points[j][0];
                        int gcd = gcd(numerator, denominator);  // 通过最大公约数来计算斜率
                        String hashStr = (numerator / gcd) + "/" + (denominator / gcd);
                        map.put(hashStr, map.getOrDefault(hashStr, 1) + 1);
                        res = Math.max(res, map.get(hashStr) + samePoint);
                    }
                }
                res = Math.max(res, sameXAxis);  // 垂直于x轴的点之前没有算
            }
            return res;
        }
    
        private int gcd(int a, int b) {  // 和GCD捆绑
            if (a == 0) return b;
            return gcd(b % a, a);
        }
}
```

边界条件：平行/重合

## 9.5 点与面

圆的表达式：`(x - a)^2 + (y -b)^2 = r ^2`.

点与圆的关系：

1. P在圆外，PO > r
2. P在圆上，PO = r
3. P在圆内，PO < r

+ 三角形

  代码：Math.abs((x1 * (y2 -y3) + x2 * (y3 -y1) + x3 * (y1 -y2)) / 2.0 )

  ![image-20220713183938844](C:\zwh\Documents\myBlog\三角形)

​		

## 9.6 线段是否相交

判断两条线段是否相交：

1. 如果以一条线段的两个头为端点，另一条线段的两个端点一定在他们的两边。

2. 平行相交的话要先判断是否平行，再判断是否一条线段的端点在另一条上面

   ```java
    public class Point {
           int x;
           int y;
   
           public Point(int x, int y) {
               this.x =x ;
               this.y = y;
           }
       }
   
       public boolean onSegment(Point p, Point q, Point r) {
           if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x)
                   && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y)) {
               return true;
           }
           return false;
       }
   
       public boolean pointOnSegment(Point C, Point A, Point B) {
           Point AC = new Point(C.x - A.x, C.y - A.y);
           Point BC = new Point(C.x - B.x, C.y - B.y);
           int res = AC.x * BC.y - AC.y * BC.x;
           return res == 0 && onSegment(A, C, B);
       }
   
       public int orientation(Point p, Point q, Point r) {
           int res = (q.y - p.y) * (r.x - q.x) - (q.x - p .x) * (r.y - q.y);
           if (res == 0) return 0;
           return res >0 ? 1 : 2;  // 0 是平行，1是在左边2是在右边
       }
   
       // 线段相交
       public boolean segmentIntersect(Point p1, Point q1, Point p2, Point q2) {
           int o1 = orientation(p1, q1, p2);
           int o2 = orientation(p1, q1, q2);
           int o3 = orientation(p2, q2, p1);
           int o4 = orientation(p2, q2, q1);
           if (o1 != o2 && o3 != o4) return true;  // 不平行的情况
           if (o1 == 0 && onSegment(p1, p2, q1)) return true;  // 平行的情况，其中一个点在另一个直线上
           if (o2 == 0 && onSegment(p1, q2, q1)) return true;
           if (o3 == 0 && onSegment(p2, p1, q2)) return true;
           if (o4 == 0 && onSegment(p2, q1, q2)) return true;
           return false;
       }
   
   ```

## 9.7 点是否在多边形内

+ 扫描线算法，对于每一条扫描线的处理：
  1. 求交点
  2. 交点排序
  3. 交点匹配
  4. 区间填充
  5. 排序和交点

## 9.8 圆

+ 方格与圆

  给一个圆，半径和圆心点的坐标，求有多少整数完全在圆内？

  + 取整

    ```java
    public int circlePoint(double r) {
    	int res = 0;
    	for (int x = 0, x < r; x ++) {
    		int y = (int)Math.sqrt(r * r - x * x);
    		res += y;
    	}
    	return res * 4 + 1;
    }
    ```



+ 二分图

  # [785\. Is Graph Bipartite?](https://leetcode.com/problems/is-graph-bipartite/)

  ## Description

  Difficulty: **Medium**  

  Related Topics: [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Union Find](https://leetcode.com/tag/union-find/), [Graph](https://leetcode.com/tag/graph/)


  There is an **undirected** graph with `n` nodes, where each node is numbered between `0` and `n - 1`. You are given a 2D array `graph`, where `graph[u]` is an array of nodes that node `u` is adjacent to. More formally, for each `v` in `graph[u]`, there is an undirected edge between node `u` and node `v`. The graph has the following properties:

  *   There are no self-edges (`graph[u]` does not contain `u`).
  *   There are no parallel edges (`graph[u]` does not contain duplicate values).
  *   If `v` is in `graph[u]`, then `u` is in `graph[v]` (the graph is undirected).
  *   The graph may not be connected, meaning there may be two nodes `u` and `v` such that there is no path between them.

  A graph is **bipartite** if the nodes can be partitioned into two independent sets `A` and `B` such that **every** edge in the graph connects a node in set `A` and a node in set `B`.

  Return `true` _if and only if it is **bipartite**_.

  **Example 1:**

  ![](https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg)

  ```
  Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
  Output: false
  Explanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.
  ```

  **Example 2:**

  ![](https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg)

  ```
  Input: graph = [[1,3],[0,2],[1,3],[0,2]]
  Output: true
  Explanation: We can partition the nodes into two sets: {0, 2} and {1, 3}.
  ```

  **Constraints:**

  *   `graph.length == n`
  *   `1 <= n <= 100`
  *   `0 <= graph[u].length < n`
  *   `0 <= graph[u][i] <= n - 1`
  *   `graph[u]` does not contain `u`.
  *   All the values of `graph[u]` are **unique**.
  *   If `graph[u]` contains `v`, then `graph[v]` contains `u`.


  ## Solution

  Language: **Java**

  ```java
  class Solution {
      public boolean isBipartite(int[][] graph) {
            // 先对点进行着色
              int[] colors = new int[graph.length];
              for (int i = 0; i < colors.length; i++) {
                  if (colors[i] == 0 ) {
                      Queue<Integer> queue = new LinkedList<>();
                      queue.offer(i);
                      colors[i] = 1;  // 如果没有着色就将当前的位置着色
                      while (!queue.isEmpty()) {
                          Integer node = queue.poll();
                          for (int adjacent : graph[node]) {  // 找相邻的两个点
                              if (colors[adjacent] == colors[node]) return false;  // 一旦相邻的两个点产生冲突了就不行
                              else if (colors[adjacent] == 0) {  // 如果相邻的点没有着色
                                  queue.offer(adjacent);  // 加入队列
                                  colors[adjacent] = -colors[node];  // 将相邻的点着色成 -1
                              }
                          }
                      }
                  }
              }
              return true;
      }
  }
  ```

## 9.9 正方形

平面有若干个点，问能组成多少正方形（平行与x轴）

+ 两点（对角线的点）确定一个正方形

+ 边长相等

+ 对角线垂直平分, 中点加长度

  ```java
  public int countSquare(List<Point> list ) {
  	if (list.size() == 0) return 0;
  	int res = 0;
      HashSet<Point> set = new HashSet<>();  // 点的集合
      for (Point point : list) set.add(point);
  	for (int i = 0; i < list.size(); i ++) {
  		Point node1 = list.get(i); // 对角线的第一个点
  		for (int j = i + 1; j < list.size(); j++) {
  			Point node 2 = list.get(j);  // 第二个点
              if (Math.abs(node1.x - node2.x) != Math.abs(node1.y - node2.y)  // 长方形去掉这一行
                 || node1.equals(node2)) countinue;
              Point left = new Point(node1.x, node2.y);
              Point right = new Point(node2.x, node1.y);
              if (set.contains(left) && set.contains(right)) res++;
  		}
  	}
  	return res / 2;  // 会重复计算两次
  }
  ```


不平行与x轴呢：

```
```



# 10. Heap

## 10.1 Heap的实现 & PriorityQuque

+ 默认升序排列，其他排列顺序需重写compare函数

  ```java
  public static void compare1(){
      int[] nums = new int[]{1, 2 ,3, 4};
      PriorityQueue<Integer> priorityQueue = new PriorityQueue<>(new Comparator<Integer>() {
          @Override
          public int compare(Integer o1, Integer o2) {
              return o2 - o1;  // 默认为升序排列，降序排列为2-1
          }
      });
      for (int num : nums) {
          priorityQueue.offer(num);
      }
  }
  ```

+ Lamda表达式形式

  

```java
 public class ListNode {
        int val;
        Note5_LinkedList.ListNode next;

        ListNode() {
        }

        ListNode(int val) {
            this.val = val;
        }

        ListNode(int val, Note5_LinkedList.ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

public static void compare4() {
    int[] nums = new int[] {1 ,2 ,3 , 4};
    PriorityQueue<ListNode> priorityQueue = new PriorityQueue<>(5, (a, b) -> (a.val - b.val));  // lamda表达式

}
```

## 10.2 全排列 VS 局部排序

排序：

1. 全排序：Arrays.sort

2. 部分排序：PriorityQueue: 凡是看到元素间局部排序，涉及到最大，最小，用PriorityQueue

   时间复杂：Arrays.sort: nlogn, PriorityQueue: nlogk

   # [215\. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)

   ## Description

   Difficulty: **Medium**  

   Related Topics: [Array](https://leetcode.com/tag/array/), [Divide and Conquer](https://leetcode.com/tag/divide-and-conquer/), [Sorting](https://leetcode.com/tag/sorting/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/), [Quickselect](https://leetcode.com/tag/quickselect/)


   Given an integer array `nums` and an integer `k`, return _the_ k<sup>th</sup> _largest element in the array_.

   Note that it is the k<sup>th</sup> largest element in the sorted order, not the k<sup>th</sup> distinct element.

   You must solve it in `O(n)` time complexity.

   **Example 1:**

   ```
   Input: nums = [3,2,1,5,6,4], k = 2
   Output: 5
   ```

   **Example 2:**

   ```
   Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
   Output: 4
   ```

   **Constraints:**

   *   1 <= k <= nums.length <= 10<sup>5</sup>
   *   -10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>


   ## Solution

   Language: **Java**

   ```java
   class Solution {
       public int findKthLargest(int[] nums, int k) {
             if (nums == null || nums.length == 0) {
               return 0;
           }
           PriorityQueue<Integer> minHeap = new PriorityQueue<>();
           for (Integer num : nums) {
               minHeap.offer(num);
               if (minHeap.size() > k) {
                   minHeap.poll();
               }
           }
           return minHeap.poll();
       }
   }
   ```

## 10.3 Arrays.sort

+ Arrays.sort也可以重写 compareTo接口

  # [56\. Merge Intervals](https://leetcode.com/problems/merge-intervals/submissions/)

  ## Description

  Difficulty: **Medium**  

  Related Topics: [Array](https://leetcode.com/tag/array/), [Sorting](https://leetcode.com/tag/sorting/)


  Given an array of `intervals` where intervals[i] = [start<sub>i</sub>, end<sub>i</sub>], merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_.

  **Example 1:**

  ```
  Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
  Output: [[1,6],[8,10],[15,18]]
  Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
  ```

  **Example 2:**

  ```
  Input: intervals = [[1,4],[4,5]]
  Output: [[1,5]]
  Explanation: Intervals [1,4] and [4,5] are considered overlapping.
  ```

  **Constraints:**

  *   1 <= intervals.length <= 10<sup>4</sup>
  *   `intervals[i].length == 2`
  *   0 <= start<sub>i</sub> <= end<sub>i</sub> <= 10<sup>4</sup>


  ## Solution

  Language: **Java**

  ```java
  class Solution {
      public int[][] merge(int[][] intervals) {
           if (intervals == null || intervals.length == 0) return new int[][]{};
              Arrays.sort(intervals, (a,b) -> (a[0] - b[0]));  //  按起点的大小进行升序排列
              List<int[]> res = new ArrayList<>();
              int start = intervals[0][0];
              int end = intervals[0][1];
              for (int[] interval : intervals) {
                  if (interval[0] <= end) end = Math.max(interval[1], end);  // 如果后一个的start小于end,将前一个的end更新为后一个的end
                  else {
                      res.add(new int[]{start, end});
                      start = interval[0];
                      end = interval[1];
                  }
              }
              res.add(new int[]{start, end});
              return res.toArray(new int[][]{});
      }
  }
  ```

## 10.4 pair和时间复杂度

1. 部分排序：低级大，第几小

2. 涉及 Pair类型，两个变量，大多要有先后顺序（优先级）

3. 只要涉及到排序优先级就是priorityqueue和 arrays.sort

   # [373\. Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/)

   ## Description

   Difficulty: **Medium**  

   Related Topics: [Array](https://leetcode.com/tag/array/), [Heap (Priority Queue)](https://leetcode.com/tag/heap-priority-queue/)


   You are given two integer arrays `nums1` and `nums2` sorted in **ascending order** and an integer `k`.

   Define a pair `(u, v)` which consists of one element from the first array and one element from the second array.

   Return _the_ `k` _pairs_ (u<sub>1</sub>, v<sub>1</sub>), (u<sub>2</sub>, v<sub>2</sub>), ..., (u<sub>k</sub>, v<sub>k</sub>) _with the smallest sums_.

   **Example 1:**

   ```
   Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
   Output: [[1,2],[1,4],[1,6]]
   Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
   ```

   **Example 2:**

   ```
   Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
   Output: [[1,1],[1,1]]
   Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
   ```

   **Example 3:**

   ```
   Input: nums1 = [1,2], nums2 = [3], k = 3
   Output: [[1,3],[2,3]]
   Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]
   ```

   **Constraints:**

   *   1 <= nums1.length, nums2.length <= 10<sup>5</sup>
   *   -10<sup>9</sup> <= nums1[i], nums2[i] <= 10<sup>9</sup>
   *   `nums1` and `nums2` both are sorted in **ascending order**.
   *   1 <= k <= 10<sup>4</sup>


   ## Solution

   Language: **Java**

   ```java
   class Solution {
       public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
            List<List<Integer>> res = new ArrayList<>();
               if (nums1.length == 0 || nums2.length == 0 || k == 0) return res;
               PriorityQueue<int[]> priorityQueue = new PriorityQueue<>((a,b) -> (a[0] + a[1] - b[0] - b[1]));  //  lamda重写compare方法
               for (int i = 0; i < k && i < nums1.length; i++) {  //  只需要加入k个元素，num1和num2[0]加入，第三个index位置对应的是nums2的index
                   priorityQueue.offer(new int[]{nums1[i], nums2[0], 0});
               }
               while (!priorityQueue.isEmpty() && k-- > 0) {
                   int[] cur = priorityQueue.poll();  // 取出第一小和的元素
                   List<Integer> temp = new ArrayList<>();
                   temp.add(cur[0]);
                   temp.add(cur[1]);
                   res.add(temp);
                   if (cur[2] == nums2.length - 1) continue;  // cur[2]的最后一个元素了，相当于nums2没有元素可以加了
                   priorityQueue.offer(new int[]{cur[0], nums2[cur[2] + 1], cur[2] + 1});  // 加入nums[2]的下一个位置的元素和num1当前的元素，index ++
               }
               return res;
       }
   }
   ```



## 10.5 Class 排序

类，多个变量，有先后顺序

+ 外排序（External sorting): 大文件的排序，待排序的文件无法一次装入内存

  1. 空间不够，化大为下，拆分

  2. 使用内排序方法排序

  3. 问题：merge k srted arrays

     ```java
     // merge k sorted arrays
     
     /**
      * array1: [1, 3, 5, 7]
      * array2: [2, 4 ,6 ,8]
      * array3: [0, 9, 10, 11]
      * 将这三个array组合为一个sorted array
      * [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
      */
     class mergeKsortedArrays{
         public static int[] mergeKSortedArrays(int[][] arrays) {
             List<Integer> ret = new ArrayList<>();
             if (arrays == null || arrays.length == 0) return new int[]{};
     
             PriorityQueue<ArrayContainer> priorityQueue = new PriorityQueue<>();  // 比较每个array的起始位置的大小，一个个装进新的数组
             for (int i = 0; i < arrays.length; i++) {
                 if (arrays[i].length != 0) {
                     ArrayContainer ac = new ArrayContainer(arrays[i], 0);
                     priorityQueue.offer(ac);
                 }
             }
     
             while (!priorityQueue.isEmpty()) {
                 ArrayContainer ac = priorityQueue.poll();  // 将当前位置最小的那个poll出来加入ret，并且把index++
                 ret.add(ac.array[ac.index++]);  
                 if (ac.index < ac.array.length) priorityQueue.offer(new ArrayContainer(ac.array,ac.index));  // 加入下一个
             }
     
             int[] res = new int[ret.size()];
             for (int i = 0; i < res.length; i++) {
                 res[i] = ret.get(i);
             }
             return res;
         }
     
         // 新建一个class来表示 array和它的起始值（当前遍历到的 index）
         private static class ArrayContainer implements Comparable<ArrayContainer> {
             // 放入array和它的起始位置
             int[] array;
             int index;
     
             public ArrayContainer(int[] array, int index) {
                 this.array = array;
                 this.index = index;
             }
     
             @Override
             public int compareTo(ArrayContainer o) {
                 return this.array[index] - o.array[o.index];  // 按照index位置的大小升序排列
             }
         }
     }
     ```

     + 模板

       ```java
       // 处理数据 Arrays.sort 混合应用
       PriorityQueue<T> priorityQueue = new PriorityQueue<>((a,b) -> 重写比较)；
       for(遍历原数据) {
       	priorityQueue.offer();  // 加入数据
       }
       while() {
           // 处理数据
       }
       /// 时间复杂度：O(nlohn) / O(nlogk)
       ```

       



# 11. 回溯法

按条件进行搜索，当探索到某一步时，发现原先的选择达不到目标或不是最优，就退回一步重新选择，这个过程叫做回溯。

+ 实现：递归（枚举）
+ DFS: 全部解，全部枚举
+ Backtracking: 部分解，部分枚举，相当于剪枝的DFS

## 11 .1 二叉树的遍历

+ 三种遍历方式

  1. 前序遍历（根节点开始），顺序是**根节点** -> 左子树 -> 右子树

     ```java
     public void preOrder(TreeNode node) {
     	if ("终止条件") // 必须要有
     		return;
     	逻辑处理  // 不是必须的
     	递归调用  // 必须要有
     }
     ```

     **终止条件**是node等于空，**逻辑处理**这块直接打印当前节点的值即可，**递归调用**是先打印左子树在打印右子树:

     ```java
     public void preOrder(TreeNode node) {
     	if (node == null) return;
     	System.out.println(node.val + "");
     	preOrder(node.left);
     	preOrder(node.right);
     }
     ```

  2. 中序遍历 （根节点再中间），左子树 -> **根节点** -> 右子树

     ```java
     public void inOrder(TreeNode node) {
     	if (node == null) return;
     	inOrder(node.left);
     	System.out.println(node.val);
     	inOrder(node.right);
     }
     ```

  3. 后序遍历（根节点再最后），左子树 -> 右子树 -> **根节点**

     ```java
     public void postOrder(TreeNode tree) {
     	if (tree == null) return;
     	postOrder(tree.left);
     	postOrder(tree.right);
     	Syste.out.println(tree.val);
     }
     ```

     

+ 模板

  ```java
  private void backTrack("原始函数") {
  	// 终止条件
      if ("终止条件") {
          // 一些逻辑，（可有可无，视情况而定）
          return;
      }
      for (int i = "for 循环开始的参数"; i < "for循环借宿的参数"; i++) {
          // 一些逻辑操作（可有可无）
          
          // 做出选择
          
          // 递归
          backtrack("新的参数");
          // 一些逻辑操作（可有可无，视情况而定）
          
          // 撤销选择
      }
  }
  ```

  + 为什么要最后一步撤销选择：

    递归分为递和归两部分，递就是往下传递，归就是往回走。递归你从什么地方调用最终还会回到什么地方去，我们来画个简单的图看一下

    ![递归](https://mmbiz.qpic.cn/mmbiz_png/PGmTibd8KQBEPUibuD2icIj0YTAfagvF110FIEMic6s7zfagYiczv1Bzia6CNicg32Iv3TkxgZGd3hvbChSQ91XFxcTXw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
	
	  
	
	  这是一棵非常简单的3叉树，假如要对他进行DFS遍历，当沿着1→2这条路径走下去的时候，list中应该是[1，2]。因为是递归调用最终还会回到节点1，如果不把2给移除掉，当沿着1→4这个分支走下去的时候就变成[1，2，4]，但实际上1→4这个分支的结果应该是[1，4]，这是因为我们把前一个分支的值给带过来了。当1，2这两个节点遍历完之后最终还是返回节点1，在回到节点1的时候就应该把结点2的值给移除掉，让list变为[1]，然后再沿着1→4这个分支走下去，结果就是[1，4]。

## 11.2 三大题型：排列

+ # [46\. Permutations](https://leetcode.com/problems/permutations/)

  ## Description

  Difficulty: **Medium**  

  Related Topics: [Array](https://leetcode.com/tag/array/), [Backtracking](https://leetcode.com/tag/backtracking/)


  Given an array `nums` of distinct integers, return _all the possible permutations_. You can return the answer in **any order**.

  **Example 1:**

  ```
  Input: nums = [1,2,3]
  Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
  ```

  **Example 2:**

  ```
  Input: nums = [0,1]
  Output: [[0,1],[1,0]]
  ```

  **Example 3:**

  ```
  Input: nums = [1]
  Output: [[1]]
  ```

  **Constraints:**

  *   `1 <= nums.length <= 6`
  *   `-10 <= nums[i] <= 10`
  *   All the integers of `nums` are **unique**.


  +  Solution

  Language: **Java**

  ```java
  class Solution {
      public List<List<Integer>> permute(int[] nums) {
          List<List<Integer>> res = new ArrayList<>();
              backtrack(res, new ArrayList<>(), nums);
              return res;
          }
  
          private void backtrack(List<List<Integer>> list, List<Integer> temp, int[] nums) {
              // 终止条件，如果数字被用完了，说明找到了一个排列（可以把它看成n叉树到叶子节点了，不能往下走了，要返回）
              if (temp.size() == nums.length) {
                  list.add(new ArrayList<>(temp));
                  return;
              }
              // 遍历n叉树的每个节点的子节点
              for (int i = 0; i < nums.length; i++) {
                  // 不能有重复的，有就要跳过
                  if (temp.contains(nums[i])) continue;
                  temp.add(nums[i]);
                  backtrack(list, temp, nums);
                  temp.remove(temp.size() - 1);
              }
          }
      }
  
  ```

## 11.3 三大题型：子集

+ # [78\. Subsets](https://leetcode.com/problems/subsets/)

  ## Description

  Difficulty: **Medium**  

  Related Topics: [Array](https://leetcode.com/tag/array/), [Backtracking](https://leetcode.com/tag/backtracking/), [Bit Manipulation](https://leetcode.com/tag/bit-manipulation/)


  Given an integer array `nums` of **unique** elements, return _all possible subsets (the power set)_.

  The solution set **must not** contain duplicate subsets. Return the solution in **any order**.

  **Example 1:**

  ```
  Input: nums = [1,2,3]
  Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
  ```

  **Example 2:**

  ```
  Input: nums = [0]
  Output: [[],[0]]
  ```

  **Constraints:**

  *   `1 <= nums.length <= 10`
  *   `-10 <= nums[i] <= 10`
  *   All the numbers of `nums` are **unique**.


  ## Solution

  Language: **Java**

  ```java
  class Solution {
      public List<List<Integer>> subsets(int[] nums) {
          List<List<Integer>> res = new ArrayList<>();
          if (nums == null || nums.length == 0) return res;
          subsetsHelper(res, new ArrayList<>(), nums, 0);
          return res;
      }
      
      private void subsetsHelper(List<List<Integer>> res, List<Integer> list, int[] nums, int index) {
          res.add(new ArrayList<>(list));  // 没有限制，直接加入
          for (int i = index; i < nums.length; i++) {  // Index: 已经算过的数字不用去管了
              list.add(nums[i]);
              subsetsHelper(res, list, nums, i + 1);
              list.remove(list.size() -1);
          }
          
      }
  }
  ```

## 11.4 模板

```java
public static List<LIst<Integer>> backtracking(int[] nums) {
	List<List<Integer>> res = new ArrayList<>();  // result 数组
	if (nums == null || nums.length == 0) return res;
	helper(res, new ArrayList<>(), nums, 0);
	return res;
}

// 参数，分析得出res + list + 输入 + index（看情况）
public static void helper(List<LIst<Integer>> res, List<Integer> list, int[] nums, ...) {
	// 返回条件 + res.add(new ArrayList<>(list));
	for (int i = ...; i < nuns.length; i++) {
		list.add(nums[i]);
		helper(res, list, nums ...);
		list.remove(list.size() - 1);  // java是值传递，list是一个对象，是一个引用，要把这一次的删除才不影响上一层的
	}
}
```

# 12. 图



## 12.1 Flood fill 的 DFS

把一个点所有相邻的点都涂上统一颜色，一直填充下去，知道这个区域内所有的点都被填充完为止

+ # [200\. Number of Islands](https://leetcode.com/problems/number-of-islands/)

  ## Description

  Difficulty: **Medium**  

  Related Topics: [Array](https://leetcode.com/tag/array/), [Depth-First Search](https://leetcode.com/tag/depth-first-search/), [Breadth-First Search](https://leetcode.com/tag/breadth-first-search/), [Union Find](https://leetcode.com/tag/union-find/), [Matrix](https://leetcode.com/tag/matrix/)


  Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return _the number of islands_.

  An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

  **Example 1:**

  ```
  Input: grid = [
    ["1","1","1","1","0"],
    ["1","1","0","1","0"],
    ["1","1","0","0","0"],
    ["0","0","0","0","0"]
  ]
  Output: 1
  ```

  **Example 2:**

  ```
  Input: grid = [
    ["1","1","0","0","0"],
    ["1","1","0","0","0"],
    ["0","0","1","0","0"],
    ["0","0","0","1","1"]
  ]
  Output: 3
  ```

  **Constraints:**

  *   `m == grid.length`
  *   `n == grid[i].length`
  *   `1 <= m, n <= 300`
  *   `grid[i][j]` is `'0'` or `'1'`.


  + **Solution**

  Language: **Java**

  ```java
  class Solution {
        private int m;
          private int n;
          public int numIslands(char[][] grid) {
              if (grid == null || grid.length == 0) return 0;
              m = grid.length;
              n = grid[0].length;
              int res =0;
              for (int i = 0; i < m; i++) {
                  for (int j = 0; j < n; j++) {
                      if (grid[i][j] == '1') {  // 当遍历到1的时候进行flood fill
                          floodfill(grid, i, j);
                          res++;
                      }
                  }
              }
              return res;
          }
  
          private void floodfill(char[][] grid, int i, int j) {
              if (i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == '0') return;  // 如果遍历到边界或者遇到了0就返回
              grid[i][j] = '0';  // 把当前位置变为0
              floodfill(grid, i , j + 1);  // 上下左右都进行遍历
              floodfill(grid, i , j - 1);
              floodfill(grid, i + 1 , j);
              floodfill(grid, i - 1, j);
          }
  
       private void floodfillBFS(char[][] grid, int x, int y) {
              grid[x][y] = '0';
              Queue<Integer> queue = new LinkedList<>();
              queue.offer(x * n + y);  // 将2d的元素扯成一条线，x*行数+y
              while (!queue.isEmpty()) {
                  int cur = queue.poll();
                  int i = cur / n;  // 行数
                  int j = cur % n;  // 列数
                  if (i > 0 && grid[i - 1][j] == '1') {  // 判断上下左右四个位置
                      queue.offer((i - 1) * n + j);  // 上面位置是1
                      grid[i - 1][j] = '0'; // 加入进去，把当前位置变成0
                  }
                  if (i < m -1 && grid[i + 1][j] == '1') {  // 下面位置
                      queue.offer((i + 1) * n + j);
                      grid[i + 1][j] = '0';
                  }
                  if (j > 0 && grid[i][j -1] == '1') {  // 左边位置
                      queue.offer(i * n + j - 1);
                      grid[i][j - 1]='0';
                  }if (i < n - 1 && grid[i][j + 1] == '1') {  // 右边位置
                      queue.offer((i * n + j + 1);
                      grid[i][j + 1] = '0';
                  }
              }
          }
  }
  ```



+ BFS的优化

  ```java
  private void bfs(char[][] grid, int x, int y){
              int[][] directions = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};  // 上下左右四个方向
              Queue<Point> queue = new LinkedList<>();
              queue.offer(new Point(x, y));
              while(!queue.isEmpty()) {
                  Point cur = queue.poll();
                  for(int[] direction : directions) {  // 四个方向进行遍历
                      int newX = cur.x + direction[0];
                      int newY = cur.y + direction[1];
                      if (isValid(grid, newX, newY)) {  // 判断边界条件
                          queue.offer(new Point(newX, newY));  // 加入新的点
                          grid[newX][newY] = '0';
                      }
                  }
              }
          }
  
          private boolean isValid(char[][] grid, int x, int y) {
              return x >= 0 && y >= 0 && x < grid.length && y < grid[0].length && grid[x][y] == '1';
          }
  
          class Point{
              int x;
              int y;
              public Point(int x, int y) {
                  this.x = x;
                  this.y = y;
              }
          }
  ```

  

## 12.2 棋盘迷宫


0代表障碍物，1代表路，求到目的地的最段路径

```java
public class mazeOfChessBoard{
    private boolean hasPath(char[][] maze, int[] start, int[] end){  // 从七点走到终点
        int[][] directions = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};  // 上下左右四个方向

        boolean[][] visited = new boolean[maze.length][maze[0].length];  // 记录走的路径

        Queue<solution200.Point> queue = new LinkedList<>();
        queue.offer(new solution200.Point(start[0], start[1]));  // 初始化，加入起点
        visited[start[0]][start[1]] = true;

        while(!queue.isEmpty()) {
            solution200.Point cur = queue.poll();
            if (cur.x == end[0] && cur.y == end[1]) return true;  // 走到终点的时候return true
            for(int[] direction : directions) {  // 四个方向进行遍历
                int newX = cur.x + direction[0];
                int newY = cur.y + direction[1];
                if (isValid(maze, newX, newY) && !visited[newX][newY]) {  // 判断边界条件, 如果没有走过，再走它
                    queue.offer(new solution200.Point(newX, newY));
                    visited[newX][newY] = true;  // 将当前节点变为true
                }
            }
        }
        return false;
    }

    private boolean isValid(char[][] grid, int x, int y) {
        return x >= 0 && y >= 0 && x < grid.length && y < grid[0].length && grid[x][y] == '1';
    }

    class Point{
        int x;
        int y;
        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

}
```







